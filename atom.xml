<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识博客</title>
  
  <subtitle>知识博客</subtitle>
  <link href="https://daoxuan.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://daoxuan.gitee.io/"/>
  <updated>2022-04-24T01:57:05.000Z</updated>
  <id>https://daoxuan.gitee.io/</id>
  
  <author>
    <name>Alex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac.oh-my-zsh</title>
    <link href="https://daoxuan.gitee.io/2022/04/24/9329f2b80cc6.html"/>
    <id>https://daoxuan.gitee.io/2022/04/24/9329f2b80cc6.html</id>
    <published>2022-04-24T01:57:01.000Z</published>
    <updated>2022-04-24T01:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%AE%89%E8%A3%85">安装</a></li><li><a href="#%E5%8D%87%E7%BA%A7">升级</a></li><li><ahref="#%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0">关闭自动更新</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><ol type="1"><li><a href="https://github.com/ohmyzsh/ohmyzsh">github地址</a></li><li>https://blog.csdn.net/u011675334/article/details/109149782</li><li>https://juejin.cn/post/6923448225571700750</li><li></li></ol><h2 id="简介">简介</h2><blockquote><p>iTerm2 终端</p></blockquote><h2 id="安装">安装</h2><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>Method</th><th>Command</th></tr></thead><tbody><tr class="odd"><td><strong>curl</strong></td><td><code>sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></td></tr><tr class="even"><td><strong>wget</strong></td><td><code>sh -c "$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></td></tr><tr class="odd"><td><strong>fetch</strong></td><td><code>sh -c "$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code></td></tr></tbody></table><h2 id="升级">升级</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">omz update</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">upgrade_oh_my_zsh</span><br></pre></td></tr></table></figure><h2 id="关闭自动更新">关闭自动更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入配置文件</span></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment"># 找到 DISABLE_AUTO_UPDATE 设置</span></span><br><span class="line">DISABLE_AUTO_UPDATE=<span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Mac.oh-my-zsh</summary>
    
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/categories/Mac/"/>
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac.查看端口ip</title>
    <link href="https://daoxuan.gitee.io/2022/04/22/c76a095cd738.html"/>
    <id>https://daoxuan.gitee.io/2022/04/22/c76a095cd738.html</id>
    <published>2022-04-22T14:14:40.000Z</published>
    <updated>2022-04-22T14:14:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E6%96%87%E6%A1%A3">文档</a></li><li><a href="#%E5%AE%9E%E4%BE%8B">实例</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><h2 id="文档">文档</h2><blockquote><p>源文档信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ lsof --<span class="built_in">help</span></span><br><span class="line">lsof: illegal option character: -</span><br><span class="line">lsof: illegal option character: e</span><br><span class="line">lsof: no process ID specified</span><br><span class="line">lsof 4.91</span><br><span class="line"> latest revision: ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/</span><br><span class="line"> latest FAQ: ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/FAQ</span><br><span class="line"> latest man page: ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/lsof_man</span><br><span class="line"> usage: [-?abhlnNoOPRtUvVX] [+|-c c] [+|-d s] [+D D] [+|-f[cgG]]</span><br><span class="line"> [-F [f]] [-g [s]] [-i [i]] [+|-L [l]] [+|-M] [-o [o]] [-p s]</span><br><span class="line"> [+|-r [t]] [-s [p:s]] [-S [t]] [-T [t]] [-u s] [+|-w] [-x [fl]] [--] [names]</span><br><span class="line">Defaults <span class="keyword">in</span> parentheses; comma-separated <span class="built_in">set</span> (s) items; dash-separated ranges.</span><br><span class="line">  -?|-h list <span class="built_in">help</span>          -a AND selections (OR)     -b avoid kernel blocks</span><br><span class="line">  -c c  cmd c ^c /c/[bix]  +c w  COMMAND width (9)    +d s  dir s files</span><br><span class="line">  -d s  select by FD <span class="built_in">set</span>   +D D  dir D tree *SLOW?*   -i select IPv[46] files</span><br><span class="line">  -l list UID numbers      -n no host names           -N select NFS files</span><br><span class="line">  -o list file offset      -O no overhead *RISKY*     -P no port names</span><br><span class="line">  -R list paRent PID       -s list file size          -t terse listing</span><br><span class="line">  -T <span class="built_in">disable</span> TCP/TPI info  -U select Unix socket      -v list version info</span><br><span class="line">  -V verbose search        +|-w  Warnings (+)         -X file descriptor table only</span><br><span class="line">  -- end option scan</span><br><span class="line">  +f|-f  +filesystem or -file names     +|-f[cgG] Ct flaGs</span><br><span class="line">  -F [f] select fields; -F? <span class="keyword">for</span> <span class="built_in">help</span></span><br><span class="line">  +|-L [l] list (+) suppress (-) link counts &lt; l (0 = all; default = 0)</span><br><span class="line">  +|-M   portMap registration (-)       -o o   o 0t offset digits (8)</span><br><span class="line">  -p s   exclude(^)|select PIDs         -S [t] t second <span class="built_in">stat</span> timeout (15)</span><br><span class="line">  -T fqs TCP/TPI Fl,Q,St (s) info</span><br><span class="line">  -g [s] exclude(^)|select and <span class="built_in">print</span> process group IDs</span><br><span class="line">  -i i   select by IPv[46] address: [46][proto][@host|addr][:svc_list|port_list]</span><br><span class="line">  +|-r [t[m&lt;fmt&gt;]] repeat every t seconds (15);  + until no files, - forever.</span><br><span class="line">       An optional suffix to t is m&lt;fmt&gt;; m must separate t from &lt;fmt&gt; and</span><br><span class="line">      &lt;fmt&gt; is an strftime(3) format <span class="keyword">for</span> the marker line.</span><br><span class="line">  -s p:s  exclude(^)|select protocol (p = TCP|UDP) states by name(s).</span><br><span class="line">  -u s   exclude(^)|select login|UID <span class="built_in">set</span> s</span><br><span class="line">  -x [fl] cross over +d|+D File systems or symbolic Links</span><br><span class="line">  names  select named files or files on named file systems</span><br><span class="line">Anyone can list all files; /dev warnings disabled; kernel ID check disabled.</span><br></pre></td></tr></table></figure><h2 id="实例">实例</h2><p>根据具体的端口号查找(用80端口举例)，使用此命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -nP -i:80</span><br></pre></td></tr></table></figure><p>根据应用程序名查找（用QQ举例），使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -nP -i | grep QQ</span><br></pre></td></tr></table></figure><p>效果如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i:4000| grep node</span><br><span class="line">node      97563 admin   33u  IPv6 0x6b5530af6a0475c7      0t0  TCP *:terabase (LISTEN)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Mac m1 查看端口ip</summary>
    
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/categories/Mac/"/>
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot SSL</title>
    <link href="https://daoxuan.gitee.io/2022/04/21/e0a49e72a687.html"/>
    <id>https://daoxuan.gitee.io/2022/04/21/e0a49e72a687.html</id>
    <published>2022-04-21T02:24:34.000Z</published>
    <updated>2022-04-21T02:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><p><ahref="https://blog.csdn.net/qq_20051535/article/details/108249482">原文</a></p><p>准备把面试的项目上线，因为是小程序要求必须https，记录下完整流程和走过的坑</p><p>第一步 申请SSL证书 这里选了免费的 https://freessl.cn/，大家可以根据自己需求进行。</p><p>我选的离线生成，需要解析验证域名，阿里云用户可选一键生成，但需要提供授权码，不推荐</p><p><font color="red">亚洲诚信不支持小程序！！只支持电脑！！别申请错了</font></p><p>PS：需要安装他要求的一个客户端软件，根据提示解析域名就会自动成功，</p><p>如果一直验证加载没反应就改用【一键申请】之后选择【我不是阿里云用户】，就会从网页验证解析改成软件验证，可秒过）</p><figure><imgsrc="/images/Spring-Boot-SSL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDUxNTM1,size_16,color_FFFFFF,t_70.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>第二步 导出证书 每个平台导出方法不一样，我这里以我的为例</p><ol type="1"><li>通过这个网站软件导出证书</li></ol><figure><imgsrc="/images/Spring-Boot-SSL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDUxNTM1,size_16,color_FFFFFF,t_70-20220421102710130.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/images/Spring-Boot-SSL/20200826230511203.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/images/Spring-Boot-SSL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDUxNTM1,size_16,color_FFFFFF,t_70-20220421102732911.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>他会自动下载一个zip压缩包：</p><p>打开 iis的（不是tomcat文件夹，目前阿里云等SSL申请渠道都只给pfx证书，使用jks证书可能到期后更改麻烦）</p><figure><img src="/images/Spring-Boot-SSL/20200826230829424.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/images/Spring-Boot-SSL/20200826230907235.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="/images/Spring-Boot-SSL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDUxNTM1,size_16,color_FFFFFF,t_70-20220421102753088.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>第三步配置的代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:aaaaa.pfx</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">yourpassword</span></span><br><span class="line">    <span class="attr">keyStoreType:</span> <span class="string">PKCS12</span></span><br></pre></td></tr></table></figure><p>密码就是 导出证书 第五步随便写的那个密码，对应上就行写啥无所谓没要求！</p><p>文件名也是对应上就行没要求！</p><p><img src="/../images/16513709992312.jpg" /></p>]]></content>
    
    
    <summary type="html">涉及到SSL 证书申请，Spring Boot SSL配置</summary>
    
    
    
    <category term="Spring" scheme="https://daoxuan.gitee.io/categories/Spring/"/>
    
    <category term="Spring Boot" scheme="https://daoxuan.gitee.io/categories/Spring/Spring-Boot/"/>
    
    
    <category term="Spring" scheme="https://daoxuan.gitee.io/tags/Spring/"/>
    
    <category term="Spring Boot" scheme="https://daoxuan.gitee.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>工具.Charles</title>
    <link href="https://daoxuan.gitee.io/2022/04/19/43e7174d713e.html"/>
    <id>https://daoxuan.gitee.io/2022/04/19/43e7174d713e.html</id>
    <published>2022-04-19T07:47:28.000Z</published>
    <updated>2022-04-19T07:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E5%AE%89%E8%A3%85">安装</a></li><li><a href="#%E9%85%8D%E7%BD%AE">配置</a><ul><li><ahref="#%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0ip">获取本地ip</a></li><li><ahref="#%E9%85%8D%E7%BD%AE%E6%89%8B%E6%9C%BA%E4%BB%A3%E7%90%86">配置手机代理</a></li><li><a href="#%E5%85%81%E8%AE%B8%E8%AE%BF%E9%97%AE">允许访问</a></li><li><ahref="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%89%E8%A3%85ssl%E8%AF%81%E4%B9%A6">移动端安装ssl证书</a></li><li><ahref="#charle%E7%9B%91%E5%90%AC%E9%85%8D%E7%BD%AE">charle监听配置</a></li><li><ahref="#pc-%E9%85%8D%E7%BD%AE%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6">PC配置信任证书</a></li></ul></li><li><a href="#%E7%9B%91%E5%90%AC">监听</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考">参考</h2><p>https://www.jianshu.com/p/5539599c7a25</p><h2 id="安装">安装</h2><p><ahref="https://www.charlesproxy.com/download/">Charles官网下载</a></p><p>安装Android studio</p><h2 id="配置">配置</h2><h3 id="获取本地ip">获取本地ip</h3><p><img src="/images/工具.Charles/image-20220419160314861.png" alt="image-20220419160314861" style="zoom:50%;" /></p><h3 id="配置手机代理">配置手机代理</h3><blockquote><p>如下图配置。</p><p>步骤： 进入”互联网“-”互联网详情“- ”右上侧的编辑按钮“-”代理配置即可</p></blockquote><p><img src="/images/工具.Charles/image-20220419160737445.png" alt="image-20220419160737445" style="zoom:50%;" /></p><h3 id="允许访问">允许访问</h3><p><img src="/images/工具.Charles/image-20220419161220041.png" alt="image-20220419161220041" style="zoom:50%;" /></p><h3 id="移动端安装ssl证书">移动端安装ssl证书</h3><p>如下图路径获取下载证书地址 chls.pro/ssl</p><p><img src="/images/工具.Charles/image-20220419161700725.png" alt="image-20220419161700725" style="zoom:50%;" /></p><p>2.移动端浏览器访问 chls.pro/ssl 下载证书</p><p>3.移动端： “设置”-“安全”-“加密与凭据”-“安装证书“-”CA证书“</p><h3 id="charle监听配置">charle监听配置</h3><p>​<img src="/images/工具.Charles/image-20220419162547886.png" alt="image-20220419162547886" style="zoom:50%;" /></p><h3 id="pc-配置信任证书">PC 配置信任证书</h3><p><img src="/images/工具.Charles/image-20220419163210992.png" alt="image-20220419163210992" style="zoom:50%;" /></p><p>进入钥匙串对 charles证书设置 信任</p><blockquote><p>注意： 点击 “信任》” 即可配置</p></blockquote><h2 id="监听">监听</h2><p>新打开一个session 即可监听</p><p><img src="/images/工具.Charles/image-20220419162708508.png" alt="image-20220419162708508" style="zoom:50%;" /></p>]]></content>
    
    
    <summary type="html">抓包-pc端，移动端</summary>
    
    
    
    <category term="工具" scheme="https://daoxuan.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Java.内置工具.反编译class文件</title>
    <link href="https://daoxuan.gitee.io/2022/04/19/4b1bac4dca8b.html"/>
    <id>https://daoxuan.gitee.io/2022/04/19/4b1bac4dca8b.html</id>
    <published>2022-04-19T07:29:27.000Z</published>
    <updated>2022-04-19T07:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#javap">javap</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考">参考</h2><h2 id="javap">javap</h2><blockquote><p>注意： 常用 javap -c</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javap --<span class="built_in">help</span></span><br><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">jdk内置工具反编译class文件</summary>
    
    
    
    <category term="JVM" scheme="https://daoxuan.gitee.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://daoxuan.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux vi/vim</title>
    <link href="https://daoxuan.gitee.io/2022/04/19/0a35c580431e.html"/>
    <id>https://daoxuan.gitee.io/2022/04/19/0a35c580431e.html</id>
    <published>2022-04-19T02:47:57.000Z</published>
    <updated>2022-04-19T02:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-vim">什么是 vim？</a></li><li><a href="#vivim-%E7%9A%84%E4%BD%BF%E7%94%A8">vi/vim 的使用</a><ul><li><a href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令模式：</a></li><li><a href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F">输入模式</a></li><li><ahref="#%E5%BA%95%E7%BA%BF%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">底线命令模式</a></li></ul></li><li><a href="#vivim-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B">vi/vim使用实例</a><ul><li><ahref="#%E4%BD%BF%E7%94%A8-vivim-%E8%BF%9B%E5%85%A5%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F">使用vi/vim 进入一般模式</a></li><li><ahref="#%E6%8C%89%E4%B8%8B-i-%E8%BF%9B%E5%85%A5%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E4%B9%9F%E7%A7%B0%E4%B8%BA%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E5%BC%80%E5%A7%8B%E7%BC%96%E8%BE%91%E6%96%87%E5%AD%97">按下i 进入输入模式(也称为编辑模式)，开始编辑文字</a></li><li><ahref="#%E6%8C%89%E4%B8%8B-esc-%E6%8C%89%E9%92%AE%E5%9B%9E%E5%88%B0%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F">按下ESC 按钮回到一般模式</a></li><li><ahref="#%E5%9C%A8%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%8C%89%E4%B8%8B-wq-%E5%82%A8%E5%AD%98%E5%90%8E%E7%A6%BB%E5%BC%80-vi">在一般模式中按下<strong>:wq</strong> 储存后离开 vi</a></li></ul></li><li><a href="#vivim-%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E">vi/vim按键说明</a><ul><li><ahref="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E5%8F%AF%E7%94%A8%E7%9A%84%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2%E7%AD%89">第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</a></li><li><ahref="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%88%B0%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%AF%E7%94%A8%E7%9A%84%E6%8C%89%E9%92%AE%E8%AF%B4%E6%98%8E">第二部分：一般模式切换到编辑模式的可用的按钮说明</a></li><li><ahref="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%88%B0%E6%8C%87%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%AF%E7%94%A8%E7%9A%84%E6%8C%89%E9%92%AE%E8%AF%B4%E6%98%8E">第三部分：一般模式切换到指令行模式的可用的按钮说明</a></li></ul></li><li><a href="#%E8%A1%A5%E5%85%85">补充</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><p><a href="https://www.runoob.com/linux/linux-vim.html">原文</a></p><p>所有的 Unix Like 系统都会内建 vi文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p>相关文章：<ahref="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全Vim快捷键键位图— 入门到进阶</a></p><hr /><h2 id="什么是-vim">什么是 vim？</h2><p>Vim 是从 vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (https://www.vim.org/) 自己也说 vim是一个程序开发工具而不是文字处理软件。</p><p>vim 键盘图：</p><figure><img src="/images/Linux-vivim/vi-vim-cheat-sheet-sch.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><hr /><h2 id="vivim-的使用">vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Commandmode）</strong>，<strong>输入模式（Insertmode）</strong>和<strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p><h3 id="命令模式">命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入模式">输入模式</h3><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式">底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><figure><img src="/images/Linux-vivim/vim-vi-workmodel.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><hr /><h2 id="vivim-使用实例">vi/vim 使用实例</h2><h3 id="使用-vivim-进入一般模式">使用 vi/vim 进入一般模式</h3><p>如果你想要使用 vi 来建立一个名为 runoob.txt的文件时，你可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim runoob.txt</span><br></pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi的一般模式了。请注意，记得 vi后面一定要加文件名，不管该文件存在与否！</p><figure><img src="/images/Linux-vivim/078207F0-B204-4464-AAEF-982F45EDDAE9.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="按下-i-进入输入模式也称为编辑模式开始编辑文字">按下 i进入输入模式(也称为编辑模式)，开始编辑文字</h3><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT-的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong>这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><figure><img src="/images/Linux-vivim/1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="按下-esc-按钮回到一般模式">按下 ESC 按钮回到一般模式</h3><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下<strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT –不见了！</p><h3 id="在一般模式中按下-wq-储存后离开-vi">在一般模式中按下<strong>:wq</strong> 储存后离开 vi</h3><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong>即可保存离开！</p><figure><img src="/images/Linux-vivim/B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p><hr /><h2 id="vivim-按键说明">vi/vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim还有非常多的按键可以使用。</p><h3id="第一部分一般模式可用的光标移动复制粘贴搜索替换等">第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: left;">移动光标的方法</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr class="even"><td style="text-align: left;">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr class="odd"><td style="text-align: left;">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr class="even"><td style="text-align: left;">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr class="odd"><td style="text-align: left;">如果你将右手放在键盘上的话，你会发现 hjkl是排列在一起的，因此可以使用这四个按钮来移动光标。如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓"的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr class="even"><td style="text-align: left;">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr class="odd"><td style="text-align: left;">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr class="even"><td style="text-align: left;">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr class="odd"><td style="text-align: left;">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr class="even"><td style="text-align: left;">+</td><td>光标移动到非空格符的下一行</td></tr><tr class="odd"><td style="text-align: left;">-</td><td>光标移动到非空格符的上一行</td></tr><tr class="even"><td style="text-align: left;">n<space></td><td>那个 n 表示『数字』，例如 20。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space>则光标会向后面移动 20 个字符距离。</td></tr><tr class="odd"><td style="text-align: left;">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr class="even"><td style="text-align: left;">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr class="odd"><td style="text-align: left;">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr class="even"><td style="text-align: left;">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr class="odd"><td style="text-align: left;">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr class="even"><td style="text-align: left;">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr class="odd"><td style="text-align: left;">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第20 行(可配合 :set nu)</td></tr><tr class="even"><td style="text-align: left;">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr class="odd"><td style="text-align: left;">n<Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr class="even"><td style="text-align: left;">搜索替换</td><td></td></tr><tr class="odd"><td style="text-align: left;">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr class="even"><td style="text-align: left;">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr class="odd"><td style="text-align: left;">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说，如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr class="even"><td style="text-align: left;">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr class="odd"><td style="text-align: left;">使用 /word 配合 n 及 N是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr class="even"><td style="text-align: left;">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr class="odd"><td style="text-align: left;"><strong>:1,<spanclass="math inline">\(s/word1/word2/g** 或 **:%s/word1/word2/g** |从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) || **:1,\)</span>s/word1/word2/gc</strong> 或<strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr class="even"><td style="text-align: left;">删除、复制与贴上</td><td></td></tr><tr class="odd"><td style="text-align: left;">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr class="even"><td style="text-align: left;">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符，『10x』。</td></tr><tr class="odd"><td style="text-align: left;">dd</td><td>剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。</td></tr><tr class="even"><td style="text-align: left;">ndd</td><td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20行(常用)，用 p/P 可以粘贴。</td></tr><tr class="odd"><td style="text-align: left;">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr class="even"><td style="text-align: left;">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr class="odd"><td style="text-align: left;">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr class="even"><td style="text-align: left;">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr class="odd"><td style="text-align: left;">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr class="even"><td style="text-align: left;">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20行(常用)</td></tr><tr class="odd"><td style="text-align: left;">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr class="even"><td style="text-align: left;">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr class="odd"><td style="text-align: left;">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr class="even"><td style="text-align: left;">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr class="odd"><td style="text-align: left;">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr class="even"><td style="text-align: left;">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr class="odd"><td style="text-align: left;">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr class="even"><td style="text-align: left;">u</td><td>复原前一个动作。(常用)</td></tr><tr class="odd"><td style="text-align: left;">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr class="even"><td style="text-align: left;">这个 u 与 [Ctrl]+r是很常用的指令！一个是复原，另一个则是重做一次～利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr class="odd"><td style="text-align: left;">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！(常用)</td></tr></tbody></table><h3id="第二部分一般模式切换到编辑模式的可用的按钮说明">第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: left;">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr class="even"><td style="text-align: left;">a, A</td><td>进入输入模式(Insert mode)： a为『从目前光标所在的下一个字符处开始输入』， A为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr class="odd"><td style="text-align: left;">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o为在目前光标所在的下一行处输入新的一行； O为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr class="even"><td style="text-align: left;">r, R</td><td>进入取代模式(Replace mode)： r只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下ESC 为止；(常用)</td></tr><tr class="odd"><td style="text-align: left;">上面这些按键中，在 vi画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时，一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr class="even"><td style="text-align: left;">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><h3id="第三部分一般模式切换到指令行模式的可用的按钮说明">第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: left;">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr class="even"><td style="text-align: left;">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入，还是跟你对该档案的档案权限有关啊！</td></tr><tr class="odd"><td style="text-align: left;">:q</td><td>离开 vi (常用)</td></tr><tr class="even"><td style="text-align: left;">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr class="odd"><td style="text-align: left;">注意一下啊，那个惊叹号 (!) 在 vi当中，常常具有『强制』的意思～</td><td></td></tr><tr class="even"><td style="text-align: left;">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr class="odd"><td style="text-align: left;">ZZ</td><td>这是大写的 Z喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr class="even"><td style="text-align: left;">ZQ</td><td>不保存，强制退出。效果等同于 <strong>:q!</strong>。</td></tr><tr class="odd"><td style="text-align: left;">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr class="even"><td style="text-align: left;">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』这个档案内容加到游标所在行后面</td></tr><tr class="odd"><td style="text-align: left;">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr class="even"><td style="text-align: left;">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls/home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr class="odd"><td style="text-align: left;">vim 环境的变更</td><td></td></tr><tr class="even"><td style="text-align: left;">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr class="odd"><td style="text-align: left;">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>特别注意，在 vi/vim中，数字是很有意义的！数字通常代表重复做几次的意思！也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除 50 行，则是用 『50dd』 对吧！数字加在动作之前，如我要向下移动 20行呢？那就是『20j』或者是『20↓』即可。</p><h2 id="补充">补充</h2><p>插入模式</p><ol type="1"><li>自动补全：<strong>ctrl</strong> + <strong>n</strong></li><li><strong>&lt;</strong> 插入一个include，并把光标置于&lt;&gt;中间</li><li>*** 插入主函数</li><li><strong>*插入printf，并自动添加</strong>*，且把光标置于双引号中间</li></ol><p>vim快捷键补充（编辑模式）</p><ol type="1"><li>dw 删除一个单词（配合b：将光标置于所在单词的首部）</li><li>yw 复制一个单词（配合p：粘贴）</li></ol><p>vim快捷键补充（插入与编辑模式通用）</p><ol type="1"><li>运行程序</li><li>保存并编译程序（会生成二进制文件）</li></ol>]]></content>
    
    
    <summary type="html">linux 中 vim/vi操作记录</summary>
    
    
    
    <category term="Linux" scheme="https://daoxuan.gitee.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://daoxuan.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2设置代理</title>
    <link href="https://daoxuan.gitee.io/2022/04/19/e7322714733f.html"/>
    <id>https://daoxuan.gitee.io/2022/04/19/e7322714733f.html</id>
    <published>2022-04-19T02:20:17.000Z</published>
    <updated>2022-04-19T02:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86">设置代理</a></li><li><a href="#%E5%8F%96%E6%B6%88%E8%AE%BE%E7%BD%AE">取消设置</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2">快速切换</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><p><ahref="https://honglu.me/2015/11/06/%E7%BB%99iTerm%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/">原文</a></p><h2 id="设置代理">设置代理</h2><p>使用curl，wget，brew等http应用程序会调用http_proxy和https_proxy这两环境变量进行代理，通过下面方式设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:8087</span><br><span class="line">export https_proxy=$http_proxy</span><br></pre></td></tr></table></figure><h2 id="取消设置">取消设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset http_proxy https_proxy</span><br></pre></td></tr></table></figure><h2 id="快速切换">快速切换</h2><p>可以在 <code>~/.zshrc</code> 或者 <code>~/.bash_profile</code>中添加这样的alias：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias goproxy=&#x27;export http_proxy=http://127.0.0.1:8087 https_proxy=http://127.0.0.1:8087&#x27;</span><br><span class="line">alias disproxy=&#x27;unset http_proxy https_proxy&#x27;</span><br></pre></td></tr></table></figure><p>这样下次就可以很方便地切换proxy了！</p>]]></content>
    
    
    <summary type="html">iTerm2设置代理</summary>
    
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/categories/Mac/"/>
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac.安装Nginx</title>
    <link href="https://daoxuan.gitee.io/2022/04/19/85e46824c371.html"/>
    <id>https://daoxuan.gitee.io/2022/04/19/85e46824c371.html</id>
    <published>2022-04-18T22:43:44.000Z</published>
    <updated>2022-04-18T22:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E6%AD%A5%E9%AA%A4">步骤</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C">基础操作</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><ol type="1"><li><p><ahref="https://blog.csdn.net/Wjhsmart/article/details/115739192">参考文章</a></p></li><li><p>https://segmentfault.com/a/1190000022738645</p></li><li><p>https://juejin.cn/post/6986190222241464350</p></li></ol><h2 id="环境">环境</h2><blockquote><p>系统： Mac Apple M1</p><p>Docker: version 20.10.7</p><p>Homebrew 3.1.9-121-g654c78c</p></blockquote><h2 id="步骤">步骤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">brew  services start nginx</span><br></pre></td></tr></table></figure><h2 id="基础操作">基础操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看安装信息</span></span><br><span class="line">brew info nginx</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">brew uninstall nginx</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">brew service start nginx</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">brew service stop nginx</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">brew service restart nginx</span><br><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="comment"># 验证配置是否正确</span></span><br><span class="line">nginx -t </span><br><span class="line"><span class="comment"># 默认文件位置 /opt/homebrew/var/www</span></span><br><span class="line"><span class="comment"># 配置文件可在 brew info nginx 中查看</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Mac m1 安装Nginx</summary>
    
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/categories/Mac/"/>
    
    
    <category term="Mac" scheme="https://daoxuan.gitee.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="https://daoxuan.gitee.io/2022/04/17/2b5387084965.html"/>
    <id>https://daoxuan.gitee.io/2022/04/17/2b5387084965.html</id>
    <published>2022-04-17T13:26:23.000Z</published>
    <updated>2022-04-17T13:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E5%90%8D%E8%AF%8D">名词</a></li><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><ol type="1"><li>http://c.biancheng.net/view/3398.html</li></ol><h2 id="名词">名词</h2><p>路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1中，从根结点到结点 a 之间的通路就是一条路径。</p><p>路径长度：在一条路径中，每经过一个结点，路径长度都要加 1。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i层结点的路径长度为 i - 1 。图 1 中从根结点到结点 2的路径长度为 3。</p><p>结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图1 中结点 2 的权为 2，权为 4。</p><p>结点的带权路径长度(PL)：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1中结点 4的带权路径长度为 3*4 = 12 。</p><p><img src="/images/数据结构.哈夫曼树/image-20220417214831400.png" alt="image-20220417214831400" style="zoom:33%;" /></p><p>树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL”Weighted Path Length of Tree</p><h2 id="概念">概念</h2><p>当用 n个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p><p>在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。</p>]]></content>
    
    
    <summary type="html">讲解哈夫曼树</summary>
    
    
    
    <category term="数据结构" scheme="https://daoxuan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://daoxuan.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis.符号意义</title>
    <link href="https://daoxuan.gitee.io/2022/04/17/bc7562ea4e70.html"/>
    <id>https://daoxuan.gitee.io/2022/04/17/bc7562ea4e70.html</id>
    <published>2022-04-17T06:59:21.000Z</published>
    <updated>2022-04-17T06:57:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E5%88%86%E6%9E%90">分析</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><ol type="1"><li><ahref="https://www.cnblogs.com/heyonggang/p/5953070.html">原文</a></li></ol><h2 id="背景">背景</h2><p>项目使用mybatis 作为ORM .业务上需要对输入字段的内容做模糊查询。涉及到多个字段，因此使用到相关方面的知识。</p><h2 id="分析">分析</h2><p>动态SQL是mybatis的强大特性之一，mybatis在对sql语句进行预编译之前，会对sql进行动态解析，解析为一个BoundSql对象，也是在此处对动态sql进行处理。下面让我们先来熟悉下mybatis里#{}与${}的用法：</p><p>在动态sql解析过程，#{}与${}的效果是不一样的：</p><blockquote><p>{ } 解析为一个 JDBC 预编译语句（preparedstatement）的参数标记符。</p></blockquote><p>　　如以下sql语句，#{}被解析为一个参数占位符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> #&#123;name&#125;;</span><br></pre></td></tr></table></figure><p>　　会被解析为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> ?;</span><br></pre></td></tr></table></figure><blockquote><p>${ } 仅仅为一个纯碎的 string 替换，在动态 SQL解析阶段将会进行变量替换</p></blockquote><p>　　如以下sql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = $&#123;name&#125;;</span><br></pre></td></tr></table></figure><p>　　当我们传递参数“sprite”时，sql会解析为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &quot;sprite&quot;;</span><br></pre></td></tr></table></figure><p>　　可以看到预编译之前的sql语句已经不包含变量name了。</p><blockquote><p><font color="red"> ${ } 的变量的替换阶段是在动态 SQL 解析阶段，而 #{}的变量的替换是在 DBMS 中</font></p></blockquote><h2 id="总结">总结</h2><ul><li>#{} ：占位符，将传入的参数当成一个字符串，会给传入的参数加一个双引号</li><li>${} ：将传入的参数直接显示生成在sql中，不会添加引号</li><li>#{}能够很大程度上防止sql注入，${}无法防止sql注入，存在sql注入的风险。</li></ul><p>　　${}在预编译之前已经被变量替换了，如下sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> $&#123;tableName&#125; <span class="keyword">where</span> name <span class="operator">=</span> $&#123;name&#125;</span><br></pre></td></tr></table></figure><p>　　如果传入的参数tableName为user; delete user;--，那么sql动态解析之后，预编译之前的sql将变为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>; <span class="keyword">delete</span> <span class="keyword">user</span>; <span class="comment">-- where name = ?;</span></span><br></pre></td></tr></table></figure><p>　　之后的语句将作为注释不起作用，顿时我和我的小伙伴惊呆了！！！看到没，本来的查询语句，竟然偷偷的包含了一个删除表数据的sql，是删除，删除，删除！！！重要的事情说三遍，可想而知，这个风险是有多大。</p><ul><li>${}一般用于传输数据库的表名、字段名等</li><li>能用#{}的地方尽量别用${}</li></ul><p>　　进入正题，通过上面的分析，相信大家可能已经对如何动态调用表名和字段名有些思路了。示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.util.Map&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;STATEMENT&quot;</span>&gt;</span></span><br><span class="line">  select </span><br><span class="line">      $&#123;columns&#125;</span><br><span class="line">  from $&#123;tableName&#125;</span><br><span class="line">      where COMPANY_REMARK = $&#123;company&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Mybatis中 &#39;$&#39; 和 &#39;#&#39; 意义</summary>
    
    
    
    <category term="Mybatis" scheme="https://daoxuan.gitee.io/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="https://daoxuan.gitee.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP Get 传参</title>
    <link href="https://daoxuan.gitee.io/2022/04/17/ddc62c927df9.html"/>
    <id>https://daoxuan.gitee.io/2022/04/17/ddc62c927df9.html</id>
    <published>2022-04-17T06:25:13.000Z</published>
    <updated>2022-04-17T06:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><ahref="#font-colorred%E5%8F%82%E8%80%83font"><font color="red">参考</font></a></li><li><a href="#%E9%9B%B6%E6%80%BB%E7%BB%93">零、总结</a></li><li><a href="#%E4%B8%80%E8%AF%AF%E8%A7%A3">一、误解</a></li><li><a href="#%E4%BA%8C%E6%80%BB%E7%BB%93">二、总结</a><ul><li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></li></ul></li><li><ahref="#%E4%B8%89%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">三、参考文章</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考"><font color="red">参考</font></h2><p><font color="red">[原文</p><p><ahref="https://github.com/zhongxia245/blog/issues/35"></a></font></p><h2 id="零总结">零、总结</h2><blockquote><p>文章数据来源于网络，可能存在变动，但是原理是一样的。</p></blockquote><ol type="1"><li>HTTP 协议 未规定 GET 和POST的长度限制</li><li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li><li>不同的浏览器和WEB服务器，限制的最大长度不一样</li><li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度8182byte</li></ol><h2 id="一误解">一、误解</h2><p>大家都知道http 中 存在 GET 和 POST这两种最常用的请求方式。（PUT，DELETE不在本文讨论范围之内）</p><p><strong>误解：HTTP 协议下的 Get请求参数长度是有大小限制的，最大不能超过XX，而 Post是无限制的。</strong></p><p>1、首先即使有长度限制，也是限制的是<strong>整个 URI长度</strong>，<strong>而不仅仅是你的参数值数据长度</strong>。</p><p>2、HTTP 协议从未规定 GET/POST 的请求长度限制是多少。</p><p><strong>以下内容摘自 <ahref="https://my.oschina.net/leejun2005/blog/136820">《关于 HTTPGET/POST 请求参数长度最大值的一个理解误区》</a>， 文章时间为2013年的。可能以当前最新的浏览器有出入 </strong></p><blockquote><p>The HTTP protocol does not place any a priori limit on the length ofa URI. Servers MUST be able to handle the URI of any resource theyserve, and SHOULD be able to handle URIs of unbounded length if theyprovide GET-based forms that could generate such URIs. A server SHOULDreturn 414 (Request-URI Too Long) status if a URI is longer than theserver can handle (see section 10.4.15). Note: Servers ought to becautious about depending on URI lengths above 255 bytes, because someolder client or proxy implementations might not properly support theselengths.</p></blockquote><p>3、所谓的请求长度限制是由<strong>浏览器</strong>和 <strong>web服务器</strong>决定和设置的，各种浏览器和 web 服务器的设定均不一样，这依赖于各个浏览器厂家的规定或者可以根据 web服务器的处理能力来设定。</p><blockquote><p>The limit is in MSIE and Safari about 2KB, in Opera about 4KB and inFirefox about 8KB, (255 bytes if we count very old browsers) . We maythus assume that 8KB is the maximum possible length and that 2KB is amore affordable length to rely on at the server side and that 255 bytesis the safest length to assume that the entire URL will come in. If thelimit is exceeded in either the browser or the server, most will justtruncate the characters outside the limit without any warning. Someservers however may send a HTTP 414 error. If you need to send largedata, then better use POST instead of GET. Its limit is much higher, butmore dependent on the server used than the client. Usually up to around2GB is allowed by the average webserver. This is also configureablesomewhere in the server settings. The average server will display aserver-specific error/exception when the POST limit is exceeded, usuallyas HTTP 500 error.</p></blockquote><p>IE 和 Safari 浏览器 限制 2k Opera 限制4k Firefox 限制8k（非常老的版本 256byte）</p><p>如果超出了最大长度，大部分的服务器直接截断，也有一些服务器会报414错误。</p><hr /><blockquote><p>HTTP 1.1 defines Status Code 414 Request-URI Too Long for the caseswhere a server-defined limit is reached. You can see further details onRFC 2616. For the case of client-defined limits, there is no sense onthe server returning something, because the server won't receive therequest at all.</p></blockquote><p>详细可以看 RFC2616</p><blockquote><p>The server is refusing to service the request because the Request-URIis longer than the server is willing to interpret. This rare conditionis only likely to occur when a client has improperly converted a POSTrequest to a GET request with long query information, when the clienthas descended into a URI "black hole" of redirection (e.g., a redirectedURI prefix that points to a suffix of itself), or when the server isunder attack by a client attempting to exploit security holes present insome servers using fixed-length buffers for reading or manipulating theRequest-URI.</p></blockquote><hr /><h2 id="二总结">二、总结</h2><blockquote><p>各个浏览器和web服务器的最大长度</p></blockquote><p>以下内容摘自<ahref="http://www.cnblogs.com/cuihongyu3503319/p/5892257.html">《GET请求中URL的最大长度限制总结》</a>，文章内容是 2016年9月，相对比较符合当前的最新现状。</p><p>在网上查询之后，浏览器和服务器对url长度都有限制，现总结如下。</p><h3 id="浏览器">浏览器</h3><p><strong>1、IE</strong></p><p>IE浏览器（Microsoft Internet Explorer）对url长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。</p><p><strong>2、firefox</strong></p><p>firefox（火狐浏览器）的url长度限制为 65536字符，但实际上有效的URL最大长度不少于100,000个字符。</p><p><strong>3、chrome</strong></p><p>chrome（谷歌）的url长度限制超过8182个字符返回本文开头时列出的错误。</p><p><strong>4、Safari</strong></p><p>Safari的url长度限制至少为 80 000 字符。</p><p><strong>5、Opera</strong></p><p>Opera 浏览器的url长度限制为190 000 字符。Opera 9 地址栏中输入190000字符时依然能正常编辑。</p><h3 id="服务器">服务器</h3><p><strong>1、Apache</strong></p><p>Apache能接受url长度限制为8 192 字符</p><p><strong>2、IIS</strong></p><p>Microsoft Internet Information Server(IIS)能接受url长度限制为16384个字符。 这个是可以通过修改的（IIS7）<code>configuration/system.webServer/security/requestFiltering/requestLimits@maxQueryStringsetting.&lt;requestLimits maxQueryString="length"/&gt;</code></p><p><strong>3、Perl HTTP::Daemon</strong></p><p>Perl HTTP::Daemon 至少可以接受url长度限制为8000字符。PerlHTTP::Daemon中限制HTTP request headers的总长度不超过16384字节(不包括post,file uploads等)。但当url超过8000字符时会返回413错误。这个限制可以被修改，在Daemon.pm查找16×1024并更改成更大的值。</p><p><strong>4、ngnix</strong></p><p>可以通过修改配置来改变url请求串的url长度限制。</p><p>client_header_buffer_size 默认值：client_header_buffer_size 1k</p><p>large_client_header_buffers默认值 ：large_client_header_buffers 44k/8k</p><blockquote><p>由于jsonp跨域请求只能通过get请求，url长度根据浏览器及服务器的不同而有不同限制。若要支持IE的话，url长度限制为2083字符，若是中文字符的话只有2083/9=231个字符。若是Chrome浏览器支持的最大中文字符只有8182/9=909个。</p></blockquote><h2 id="三参考文章">三、参考文章</h2><ol type="1"><li><ahref="http://www.cnblogs.com/cuihongyu3503319/p/5892257.html">GET请求中URL的最大长度限制总结</a></li><li><a href="https://my.oschina.net/leejun2005/blog/136820">关于 HTTPGET/POST 请求参数长度最大值的一个理解误区</a></li></ol>]]></content>
    
    
    <summary type="html">记录Get 传参的规则，以及其中的一些问题</summary>
    
    
    
    <category term="TCP/IP" scheme="https://daoxuan.gitee.io/categories/TCP-IP/"/>
    
    <category term="Get" scheme="https://daoxuan.gitee.io/categories/TCP-IP/Get/"/>
    
    
    <category term="Get" scheme="https://daoxuan.gitee.io/tags/Get/"/>
    
  </entry>
  
  <entry>
    <title>Java1.8 parallelStream并发安全问题</title>
    <link href="https://daoxuan.gitee.io/2021/12/31/6b9b9d0eb84c.html"/>
    <id>https://daoxuan.gitee.io/2021/12/31/6b9b9d0eb84c.html</id>
    <published>2021-12-31T06:09:33.000Z</published>
    <updated>2022-04-30T08:56:48.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="目录">目录</h3><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E7%8E%AF%E5%A2%83">环境</a></li><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li><li><a href="#%E9%87%8D%E7%8E%B0">重现</a><ul><li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li><li><a href="#%E7%BB%93%E6%9E%9C">结果</a></li></ul></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a><ul><li><ahref="#%E6%96%B9%E5%BC%8F1%E4%B8%8A%E9%94%81">方式1：上锁</a></li><li><ahref="#%E6%96%B9%E5%BC%8F2%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8stream">方式2：正确使用Stream</a></li></ul></li><li><a href="#%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90">原理简析</a></li><li><a href="#%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98">定位问题</a><ul><li><ahref="#%E9%97%AE%E9%A2%981%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C">问题1：数组越界</a></li><li><ahref="#%E9%97%AE%E9%A2%982%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">问题2：数据丢失</a></li></ul></li><li><a href="#%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF">正确姿势</a></li><li><a href="#%E6%89%A9%E5%B1%95">扩展</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h3 id="参考">参考</h3><ol type="1"><li>https://xlbpowder.cn/2019/04/26/parallelStream/</li><li>https://blog.csdn.net/qq_42651904/article/details/106936140</li><li>https://www.cnblogs.com/kevin-yuan/p/13533377.html</li><li><ahref="https://codexiaomai.github.io/posts/89530ef9">部分集合浅析</a></li><li><a href="http://ifeve.com/">并发网</a></li><li><ahref="https://blog.csdn.net/Sampson_S/article/details/109149575">线程安全的集合</a></li><li><ahref="https://www.runoob.com/java/java-collections.html">集合框架</a></li></ol><h3 id="环境">环境</h3><blockquote><p>JDK:1.8</p></blockquote><h3 id="背景">背景</h3><blockquote><p>工作中遇到了关于使用==parallelStream==导致的<strong>并发安全问题</strong>，使用ArrayList容器进行数据交集等处理时，由于数据较多，希望通过并行流提高处理效率，但没考虑过线程安全问题。</p><p>解决的方法非常简单，正确的使用map、collect、reduce，或者使用线程安全容器、加锁即可。</p></blockquote><h3 id="问题">问题</h3><blockquote><p>并发安全问题是可能会遇到异常</p></blockquote><ol type="1"><li>数组越界异常：ArrayIndexOutOfBoundsException</li><li>数据丢失（已经遇到😅）</li><li>数据null 值</li></ol><h3 id="重现">重现</h3><h4 id="案例">案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test153</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">          <span class="comment">//添加100个元素到集合中</span></span><br><span class="line">          list.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(list.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;-------------------LinkedList-----------------------------------&quot;</span>);</span><br><span class="line">      <span class="comment">//添加数据的集合</span></span><br><span class="line">      List&lt;Integer&gt; list2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="comment">//使用parallelStream的遍历方法来添加元素到新的集合</span></span><br><span class="line">      list.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">          list2.add(i);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//打印添加元素之后的集合长度</span></span><br><span class="line">      System.out.println(list2.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;------------------------CopyOnWriteArrayList------------------------------&quot;</span>);</span><br><span class="line">      <span class="comment">// 解决方式</span></span><br><span class="line">      List&lt;Integer&gt; list3 = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">      <span class="comment">//使用parallelStream的遍历方法来添加元素到新的集合</span></span><br><span class="line">      list.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">          list3.add(i);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//打印添加元素之后的集合长度</span></span><br><span class="line">      System.out.println(list3.size());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">100000</span><br><span class="line">-------------------LinkedList-----------------------------------</span><br><span class="line">50415</span><br><span class="line">------------------------CopyOnWriteArrayList------------------------------</span><br><span class="line">100000</span><br></pre></td></tr></table></figure><h3 id="解决方案">解决方案</h3><h4 id="方式1上锁">方式1：上锁</h4><blockquote><p>使用线程安全的集合，底层是使用==锁==，性能低</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.synchronizedList(new ArrayList&lt;&gt;()); 此方式是把非线程安全的集合转成线程安全的集合（加锁）</span></span><br><span class="line">List&lt;Integer&gt; list3 = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">        <span class="comment">//使用parallelStream的遍历方法来添加元素到新的集合</span></span><br><span class="line">        list.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">            list3.add(i);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//打印添加元素之后的集合长度</span></span><br><span class="line">        System.out.println(list3.size());</span><br></pre></td></tr></table></figure><p>如用例所示</p><p>常用线程安全集合</p><p><ahref="https://www.cnblogs.com/wangbin2188/p/14781592.html">参考</a></p><table><colgroup><col style="width: 5%" /><col style="width: 26%" /><col style="width: 68%" /></colgroup><thead><tr class="header"><th>接口</th><th>线程不安全</th><th>线程安全</th></tr></thead><tbody><tr class="odd"><td>List</td><td>ArrayList</td><td>==CopyOnWriteArrayList==,<ahref="https://blog.csdn.net/Sampson_S/article/details/109149575">vector</a></td></tr><tr class="even"><td>Map</td><td>HashMap</td><td>ConcurrentHashMap, hashtable，Node,treeNode,treeBin,ForwardingNode</td></tr><tr class="odd"><td>Set</td><td>HashSet / TreeSet</td><td>CopyOnWriteArraySet</td></tr><tr class="even"><td>Queue</td><td>ArrayDeque / LinkedList</td><td>ArrayBlockingQueue / LinkedBlockingQueue</td></tr><tr class="odd"><td>Deque</td><td>ArrayDeque / LinkedList</td><td>LinkedBlockingDeque</td></tr></tbody></table><h4 id="方式2正确使用stream">方式2：正确使用Stream</h4><blockquote><p><ahref="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html">官方文档</a></p><p>The Collections Framework provides synchronization wrappers, whichadd automatic synchronization to an arbitrary collection, making itthread-safe.</p><p>在文档中已经有说明，需要正确使用collect，才能避免线程不安全。性能高</p><p>部分翻译：</p><p>集合框架提供了同步包装器，它为任意集合添加了自动同步，使其成为线程安全的</p><p>聚合操作和并行流使您能够实现非线程安全集合的并行性，前提是您在操作集合时不修改集合</p></blockquote><p>具体使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test153</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//添加100个元素到集合中</span></span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------Collectors.toList()------------------------------&quot;</span>);</span><br><span class="line">    List&lt;Integer&gt; list1 = list.parallelStream().collect(Collectors.toList());</span><br><span class="line">    System.out.println(list1.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： parallelStream与 collect，reduce一同使用，可以满足线程安全，但是原理是不一样的。下面细说。</p><p>在使用过程中，由collect进行数据流项的收集。不适用数据流外的变量。如果使用，就使用线程安全的集合（方式1）</p><h3 id="原理简析">原理简析</h3><p>定位问题前，需要先初步了解fork/join 框架或者分治法或者<ahref="https://www.cnblogs.com/chengxiao/p/6194356.html">归并算法</a></p><p>parallelStream 底层就是使用fork/join框架，运用分治的理念，把一个任务拆分成多个子任务去实现</p><p><img src="/images/Java1.8-parallelStream并发安全问题/image-20211231160840346.png" alt="image-20211231160840346" style="zoom:50%;" /></p><p>如图所示，一个线程的任务拆分成多个线程任务，最后合并结果。使用collect、reduce，而不使用数据流外的变量，结果正确。查看源码，原理分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口 </span></span><br><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">                  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">                  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collectors.toList()的实现</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                                   (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                   CH_ID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>以Collectors.toList() 来分析</p><p>参数： Supplier<R> supplier 提供一个非线程安全的集合 arraylist，</p><p>参数： BiConsumer&lt;R, ? super T&gt; accumulator 累加器</p><p>参数： BiConsumer&lt;R, R&gt; combiner 合并器</p></blockquote><p>这里的意思是，每个线程都有一个集合，然后使用<code>合并器</code>把各个线程的结果合并，所以不会有线程安全问题，不会丢失数据</p><h3 id="定位问题">定位问题</h3><blockquote><p>以arraylist 为例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 添加一个元素时，做了如下两步操作</span></span><br><span class="line"><span class="comment">     * 1.判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line"><span class="comment">     * 2.真正将元素放在列表的元素数组里面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//确保内部容量</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">//赋值 </span></span><br><span class="line">      <span class="comment">//需要说明的是，此处赋值，是先 elementData[size]=e</span></span><br><span class="line">      <span class="comment">// 然后 size++ </span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 验证 elementData[size++] = e;执行顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test239</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">      ints[size++] = <span class="number">4</span>;</span><br><span class="line">      System.out.println(ints[<span class="number">0</span>]);</span><br><span class="line">      System.out.println(size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>分析：add元素时，实际做了两个大的步骤：</p><ol type="1"><li>判断elementData数组容量是否满足需求</li><li>在elementData对应位置上设置值</li></ol><h4 id="问题1数组越界">问题1：数组越界</h4><blockquote><p>多个线程进行add操作时，可能会导致elementData数组越界</p><p>例如A,B线程，都要add；在ensureCapacityInternal时，要检测数组容量是否符合需求。A、B线程查看数组size都是9 ，都认为可以不扩容进行add操作。</p><p>A线程操作可以正常进行，完成后 size++ . size 是10。当B线程add，然后发现size已经是10了，elementData[10] =e,但是数组elementData容量还是10，没有扩容。会发生ArrayIndexOutOfBoundsException 异常</p></blockquote><h4 id="问题2数据丢失">问题2：数据丢失</h4><blockquote><p>elementData[size++] =e;此操作不是原子性的，单线程没问题。多线程时，容易发生一个线程的值被另一个线程覆盖</p><p>例如： A、B线程 同时add操作，size=0。 代码ensureCapacityInternal(size + 1);已经执行。此时，对A、B线程来说，size=0. A线程add完成后（elementData[0]=1） B 线程add 完成（elementData[0]=1）。size在每个线程都会 ++ ，那么 下一次add时，size 是从 size=2开始的，同时会出现数组下标为1的位置值为 null</p></blockquote><p>总结</p><p>根本原因是，两个线程调传入了同一个ArrayList，这个参数在<strong>==JVM内==</strong>以地址方式存在栈内，指向堆区的（size和object[]数组），本质上调用ArrayList add()时，是通过this.size获取堆内size，这时候两个线程操作同一个堆内变量，就会<strong>==出现读取时的值是对的，但是使用时值已经被修改了==</strong>，在此this.size，就是脏数据。ArrayList不是线程安全的容器，并发调用add就会发生线程安全的问题</p><h3 id="正确姿势">正确姿势</h3><blockquote><p>Collections框架提供的同步的包装（推荐）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用线程安全的集合 </span></span><br><span class="line">List&lt;Integer&gt; list3 = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">        <span class="comment">//使用parallelStream的遍历方法来添加元素到新的集合</span></span><br><span class="line">        list.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">            list3.add(i);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 使用  官方提供的收集器 都是安全的</span></span><br><span class="line">List&lt;Integer&gt; list1 = list.parallelStream().collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collectors.toList()</span></span><br><span class="line"><span class="comment">// Collectors.toMap()</span></span><br><span class="line"><span class="comment">// Collectors.toSet() 等等</span></span><br></pre></td></tr></table></figure><h3 id="扩展">扩展</h3><p>线程安全的list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.CopyOnWriteArrayList</span></span><br><span class="line"><span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.Collections.synchronizedList(new ArrayList())</span></span><br><span class="line">Collections.synchronizedList(<span class="keyword">new</span> ArrayList())</span><br></pre></td></tr></table></figure><p>线程安全的Set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collections.synchronizedSet(Sets.newHashSet()); <span class="comment">// jdk提供的，使用同步来保证线程安全</span></span><br><span class="line"><span class="keyword">new</span> java.util.concurrent.CopyOnWriteArraySet&lt;&gt;(); <span class="comment">// jdk提供的，底层使用 CopyOnWriteArrayList 实现，适合集合大小较小的场景</span></span><br><span class="line">com.google.common.collect.Sets.newConcurrentHashSet(); <span class="comment">// guava 提供的线程安全的 Set ，底层使用 ConcurrentHashMap 实现</span></span><br><span class="line">com.alibaba.dubbo.common.utils.ConcurrentHashSet  <span class="comment">// 底层使用 ConcurrentHashMap 实现</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java1.8 parallelStream并发安全问题</summary>
    
    
    
    <category term="JAVA" scheme="https://daoxuan.gitee.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://daoxuan.gitee.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>方法签名</title>
    <link href="https://daoxuan.gitee.io/2021/12/12/feef86e577e5.html"/>
    <id>https://daoxuan.gitee.io/2021/12/12/feef86e577e5.html</id>
    <published>2021-12-12T09:16:18.000Z</published>
    <updated>2022-04-30T08:56:48.034Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#java">Java</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><h2 id="java">Java</h2><p><ahref="https://blog.csdn.net/liu_sisi/article/details/88368846">参考</a></p><p>what is method signature in java？ 在 Java 中什么是方法签名？</p><blockquote><p>书中是这么说的： Definition: Two of the components of a methoddeclaration comprise the method signature—the method’s name and theparameter types.</p></blockquote><p>方法声明的两个组件构成了方法签名 -<strong>方法的名称</strong>和<strong>参数类型</strong>。<strong>example:</strong> 这里是一个典型的方法声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateAnswer</span><span class="params">(<span class="keyword">double</span> wingSpan, <span class="keyword">int</span> numberOfEngines,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">double</span> length, <span class="keyword">double</span> grossTons)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//do the calculation here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>上面方法的签名是:<code>calculateAnswer(double, int, double, double)</code></p><p>参考了几篇博客，知道了方法签名具体是个什么东东，以前都是模模糊糊就过去了，下面放几个博客的链接</p><blockquote><p>https://blog.csdn.net/u010592926/article/details/76637936</p><p>https://blog.csdn.net/qiuchengjia/article/details/52910884</p></blockquote>]]></content>
    
    
    <summary type="html">方法签名</summary>
    
    
    
    <category term="JAVA" scheme="https://daoxuan.gitee.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://daoxuan.gitee.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>打工法则</title>
    <link href="https://daoxuan.gitee.io/2021/11/02/36b87b5fdf67.html"/>
    <id>https://daoxuan.gitee.io/2021/11/02/36b87b5fdf67.html</id>
    <published>2021-11-02T13:59:23.000Z</published>
    <updated>2022-04-30T08:56:48.034Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目录">目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><h2 id="参考">参考</h2><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E9%9B%B6%E5%89%8D%E8%A8%80">零、前言</a></li><li><ahref="#%E4%B8%80%E8%A7%92%E8%89%B2%E5%8C%96%E6%B3%95%E5%88%99">一、角色化法则</a></li><li><a href="#%E4%BA%8C%E6%88%90%E4%B8%BAowner">二、成为Owner</a></li><li><ahref="#%E4%B8%89%E8%81%AA%E6%98%8E%E5%B7%A5%E4%BD%9C">三、聪明工作</a></li><li><ahref="#%E5%9B%9B%E6%9C%80%E7%BB%88%E4%BA%A7%E7%89%A9">四、最终产物</a></li><li><ahref="#%E4%BA%94%E8%A6%81%E4%BA%8B%E7%AC%AC%E4%B8%80">五、要事第一</a></li><li><ahref="#%E5%85%AD%E5%B7%B2%E7%9F%A5%E8%BF%81%E7%A7%BB">六、已知迁移</a></li><li><ahref="#%E4%B8%83%E8%BF%87%E7%A8%8B%E7%B2%BE%E7%BB%86%E5%8C%96">七、过程精细化</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%8E%9F%E6%96%87">原文</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="参考-1">参考</h2><h2 id="零前言">零、前言</h2><p>如题，这篇文章想通过我总结的7个法则，聊聊如何高效打工。</p><p>不管我们如何想做特立独行的少数派，打工都是现阶段，相当部分人标准化赚取面包的方式。</p><p>纵使切格瓦拉教主如何一呼百应，大家嘴上喊着打工是不可能打工的，但身体却无比诚实。</p><p>诚实如我，这段时间几乎日均投入15小时在打工上，想了想既然要分享，也没有比分享打工心得更合适的了。</p><p>那么就谨以此文，称之为打工军规也好、职场软实力也好，献给各位也许被打工困扰的同学们～</p><h2 id="一角色化法则">一、角色化法则</h2><p>为什么打工会让人心累神伤？</p><p>我会从角色化扮演的角度，来解读打工为什么让人心累神伤。</p><p>什么时候人不心累？做自己的时候不心累。</p><p>但打工几乎不可能让你做自己，你在打工时永远是角色化的你。其实不只是打工，当你进入父亲、朋友、丈夫角色的时候，也都是角色化的自己，都会面临压力。</p><p>角色化的你就不再是你，你不再是金城武也不再是刘德华，你只是一个敬业的演员，一样要和其它演员一样早起集合。</p><p>角色化的压力在于：即使你再欣赏一起开会的同事，一旦你的职位和角色要求你去和他argue方案，你也得充满专业度地去争个面红耳赤。即使你们有温暖的瞬间，在办公场所，受限于在公司的角色，你们也无法像朋友一样相处。所以，从打工这件事的本质来说，承担好岗位角色本身才是主旋律。</p><p>能够快速且专业地扮演好自己的角色，才是打工的重要目标。千万不要试图在工作中添加过多的个人情绪和喜好，试图时时刻刻做自己，这会很难被专业的打工组织、环境认可。</p><p>进一步说，如何不心累呢？</p><p>如果能够放过角色化的自己，就不会那么心累了。</p><p>比如，你是一个很腼腆的人，很不喜欢约别人开会，但工作需要你又必须如此，所以你时常纠结。</p><p>此刻建议的想法是，能够把自己融入到这个角色中，把工作角色和本我切分干净，不再把在公司开会这件事和自己的个人喜好、本我志向联系在一起，只当作是像体检、洗牙一样不太喜欢但又定期需要履行的事项即可，心理压力便不会那么大了。</p><p>不心累之后，我们还会身体累，还会有很大的压力，担心忙到焦头烂额却完不成预期目标。</p><p>在工作能力方面，我有过三次较大明显的跃迁，当我悟到这些之后，我的工作水平获得了较大的提升，现在我分享给大家。</p><h2 id="二成为owner">二、成为Owner</h2><p>第一个想法是：这事全靠我了。</p><p>刚开始打工大家都会有畏难情绪，觉得自己是新人，就应该事事请教学习。但久了你会发现，职场的信息隔离往往强到不可忽视，最了解一个岗位的人往往是从事者自己。</p><p>过分依赖于别人的信息输入，会让你停滞等待，仿佛总需要权威者的一句答复才能安心继续落地。</p><p>但这是不对的，崇尚权威会冰封自己的主观能动性，成长缓慢。</p><p>正确的思路是，意识到自己是这件事的owner，意识到自己应该做出决策并承担后果，意识到不依赖于信息输入，而是自己尝试验证来获得真知。能够有owner意识，才能逐步形成自己的工作风格，不陷于定式，能够让别人对你的工作方式和成果有所期待。</p><p>迅速独立理清自己的思路，清晰透明地推动验证、得出结论，就是最佳完成工作的开始。</p><p>欲戴王冠必承其重，有更大的权责，背后一定是更多的注视和误解，在追求成就之前，要先摆出足够独立负责、勇于付出的姿态。</p><h2 id="三聪明工作">三、聪明工作</h2><p>第二个想法是：工作不该是辛苦的。</p><p>英文也有这么一句话：work smarter not harder</p><p>含义也显而易见，工作应该是倾注智慧越做越轻松的，而不是被动承受越做越累。</p><p>职场里有相当一部分人是战术懒惰的，他们往往工作地很勤奋、很辛苦，但产出总是不多。</p><p>在打工初期，往往靠着勤奋和辛苦获得了飞速成长，但马上因为疏于思考如何更聪明地工作，而无法突破瓶颈。</p><p>战术懒惰会导致你误以为工作越辛苦越充实，所以你会更倾向于多做事、把自己的时间填满。但不经思考，往往会被困难的工作、不合时宜的工作占满精力，而真正该认真思考做出成绩的工作，被忽略掉了。衡量产出时，你只能交出10件60分次品，而其它聪明而精进的同事却可以交出2件高优先级的90分精品，虽然你付出的工作量可能更大，但从价值的角度上讲后者更多，也往往更受赏识。</p><p>衡量工作产出，是以价值和质量为标准，从来不会以功劳和苦劳为标准来衡量。假使偶尔会，长期也没人能持续苦下去，这是无意义的内卷，没人想一辈子靠苦功夫工作。</p><p>懂的聪明工作的人，对于同类问题的解法，一定是日益精进、不断迭代的。如果每一次你仍然以同样的方式去处理一个问题，你也许就存在一定的战术懒惰情况。工作的目标是不断迭代自己的工作模型和战术方法，让自己能越做越轻松，越做越精进，而不是不断加大自己的付出，试图用辛苦付出来获得慰藉。</p><p>与其下苦功夫感动自己，不如多用智慧思索如何工作地更巧妙。</p><h2 id="四最终产物">四、最终产物</h2><p>第三个想法是：每一项工作都有最终产物</p><p>我之前很喜欢从方方面面去拆解问题，形成一个个方案和分析报告，最后散落出来只是小碎片被组合后的更大碎片，问题仍然没有进展。小的问题被组合成大的问题，没有思考到底，问题越积越多，压力越来越大，没有全局地思考洞见。</p><p>直到意识到最终产物的存在，才明白自己浪费了很多时间。</p><p>首先，最终产物应该是一个独立交付的价值，比如一个如期上线的功能。</p><p>这个功能应该有完整的介绍文档，那么按照这个思路，所有的信息都应该在这个文档中，包括会议沟通、变更、需求文档和技术文档。</p><p>进一步说，如果不能被纳入到这个最终文档中的，一定是和这个目标偏差的工作，或者不算是一种产出。比如中途你解决了另一个高优系统bug，这是一个分支事件，不能被写在这个需求内，所以算另一项产出。</p><p>而人经常会遇到多事项并行的情况，你会遇到很多值得解决的问题，解决之后，会占用你的精力并带给你满足感，这种满足感会迷惑你的感知，让你忘掉最初的目标。</p><p>所以正确的方式是，每一个问题就是一个考卷，先把每一个考卷列出来，再一张张完成。而不是以每个考卷里的题目为单位，在一张张考卷上切换，那样可能每一张都不会及格。</p><p>一切都要围绕一件事的主线来进行，不在当前主线上的事情，就要另开一条新主线，而同一时间，不应该有太多条主线。</p><p>我意识到以上三个想法时，我的工作思路因而改变，获得了很大的提升，也希望能够引发大家思考和进步。</p><p>但有思路只是第一步，还需要技巧和方法经验，接下来再分享3个小方法：</p><h2 id="五要事第一">五、要事第一</h2><p>第一个方法是：先做自己最揪心的事情。</p><p>工作中往往很多事都让我们揪心，但必须要找到最揪心的那一件。最揪心意味着，你对那件事束手无策，或者完成风险极大。</p><p>而做工作，某种意义上就是排除风险，而人对于风险是有潜意识感觉的。</p><p>潜意识是不会骗人的，不管你有多少工作，多长的待办清单，总有那么一两件事是让你牵肠挂肚，焦虑到无法睡觉的。那么你要做的就是：听从你的内心，把这些事情作为最高优先级，优先地去完成。</p><p>假设最揪心的事情我们称之为P0问题，那么依次再低优先级的就是的P1和P2。我们定义P0是必须完成的，P1和P2是应该完成的，P3和P4是建议完成的。虽然继续往后我们可以排到P8甚至更多，但一般来说，超过P4优先级的，就不是当下该考虑的事情，可以暂缓一下或者拖一拖。而往往最揪心的事情，都是P0的事情，你的内心已经帮你权衡好了。</p><p>如上文所说，工作应该有最终产物，所以无论这个揪心的事情多复杂，都要找一张纸写下来，同时标清楚这个最终产物到底是什么。比如我最近揪心的是移动端搜索项目，那我就需要用一张思维导图，把移动端搜索相关我最担心的事情都写下来，一个个配上预计方案，写着写着就不会焦虑和担心了。</p><p>不要给自己设置太多并行的所谓重要事项，first thingfirst，某一时刻重要的事情永远只有一件。</p><h2 id="六已知迁移">六、已知迁移</h2><p>第二个方法是：从未知域映射到已知域。</p><p>我接手新的项目、尝试新的工作，都能比较快地上手。</p><p>核心的原因是，我擅长类比和联想，擅长把未知的问题映射到已知中考虑。</p><p>我的本职工作是产品经理，在我需要从业务运营角度分析业务商业模型时，我不会第一时间去找商业分析的方法论学习，反之，我会先把商业模型和产品模型做一个映射类比，从自己熟悉的角度来看。</p><p>比如我已知产品模型往往有增长和留存，有著名的AARRR模型，用户的获取和留存转化可以分为五大阶段。同时产品一定是某个业务的映射和反映，那么业务模型我也会拿这些已知经验去套，寻找业务模型中是否有类似的公式和逻辑。最后发现，其实业务中，也有类似的模型，比如销售七步法和获客漏斗。</p><p>但进一步，未知域一定有很多东西是无法找到映射的，因为你目前已知域是有限的，且无法全部理解未知域的本质，这个时候就是获得成长的机会。</p><p>比如，当你操盘业务的时候，不单单要考虑数据指标，还要考虑组织架构和部门合作，而映射到产品中，其实是产品模块的划分和系统服务之间的协作。这时候很多做业务的经验，比如权责边界、正向激励方法，就能反过来补充已知域，成为你做产品架构设计上的一些灵感。</p><p>总之，当你遇到极其复杂的未知问题，建议：</p><p>\1. 找到熟悉的地方，用已知去类比，打开缺口</p><p>\2. 随着未知逐步清晰，分析并联想补充到自己熟悉的已知领域中</p><p>这样坚持去做，会让你的本职工作领域建立起和更多其它知识领域的连接，能够不断联想抽象，让你习惯于复用已有经验，逐步融会贯通。</p><h2 id="七过程精细化">七、过程精细化</h2><p>第三个方法是：随波逐流的事情不要做。</p><p>人们常说go with the flow，但其实工作计划安排并不适用。</p><p>工作中有很多事情是没有目标和清晰路径的，或是因为当前还不是最佳时机，或是因为这件事价值本身没那么大。当你需要反问自己：当前是不是做某项工作的最佳时机、当前做这件事是不是有价值的时候，往往答案都是否定的。</p><p>一个没有时机目标和明确价值的事情，就是做到哪算哪，随波逐流的事情，我不建议大家做。</p><p>这并不意味着我否定了很多长期有益的事情。就算是长期有益的事情，往往都有明确的兑现周期，只是周期比较长而已，同时，长期有价值的社区，往往也有明确的价值，只是单位时间内价值比较小。并不组织大家做长期有效的事情，我真正希望大家警惕的是那些“看似有用”的形式化事项，落实下来往往发现根本无法落地，也无法制定明确计划。</p><p>比如当你写年度计划，你很希望自己能够在英语方面有所建树，但如果你的事情是“读100篇英文文章”，这就是一件很随波逐流的事情。真正有清晰价值和路径的事情，应该足够细化，比如：</p><p>\1. 在英语方面有建树，到什么程度？是否能用托福100分等来衡量？</p><p>\2.为了达到托福100分，一定不是随便“读100篇英文文章”就可以概括的，你该如何安排这100篇文章，这100篇文章该如何选择，才和托福100分有强关联，是否“读100篇英文文章”有80%以上概率保证你能达到目标？</p><p>\3.进一步，如何拆解这个实现路径，用多少时间来准备，多少时间复习？</p><p>为了能够拿到明确地产出，让自己不后悔，想真正达到的结果，一定要通过严格的过程管理来保证拿到，否则事事都随波逐流去做，就好像一边去山上放养，又不想赶羊，祈求靠运气能让所有羊按时回家一样，是完全失去掌控的。</p><p>尤其在团队合作中，项目管理的重要性，远远大于一个足够优秀的好点子。</p><p>能够用精细化过程管理拿到价值的人，才是团队最需要的。</p><h2 id="总结">总结</h2><p>最后，打个总结。</p><blockquote><p>建议1：角色化法则</p></blockquote><p>要让自己正视工作，足够专业，需要理解角色化和本我的关系，不去混淆个人喜好和角色专业该做的事情。</p><blockquote><p>建议2：成为Owner</p></blockquote><p>善于学习，但又不依靠和崇尚权威，相信自己在某一个决策当下的独特性，敢于用责任感和努力来逼近最优的决策。</p><blockquote><p>建议3：聪明工作</p></blockquote><p>要让工作越做越简单，把有限的精力投入到“更聪明地工作中”而不是“更辛苦地工作中”，关注产出而不是付出。</p><blockquote><p>建议4：最终产物</p></blockquote><p>确定好工作的主线，不断往主线上丰富内容，而不是发散地投入精力在分散的事情上，导致主线进展模糊。</p><blockquote><p>建议5：要事第一</p></blockquote><p>为了选定好的主线，要有“要事第一”的原则，不是最揪心的事情，可以暂不投入很多精力去思考，同一时间，最重要的事情永远只有一个。</p><blockquote><p>建议6：已知迁移</p></blockquote><p>如果遇到了未知的事情，先从已知入手类比，是很好的切入方式，不但能消化未知，也能将新知和已知融会贯通，让自己获得更完整的洞见。</p><blockquote><p>建议7：过程精细化</p></blockquote><p>在工作中，做每一件事，都要有明确目标和计划路径，精细化的过程管理，去思考明确目标、强关联举措和可行性，可能是职场中最需要修炼的主要能力。</p><p>以上就是：从心智，到战术，到方法层面，我总结的高效打工7条建议，希望能够帮到大家。</p><p>以上，感谢。</p><h2 id="原文">原文</h2><ol type="1"><li><a href="https://sspai.com/post/67462">原文</a></li></ol>]]></content>
    
    
    <summary type="html">打工法则</summary>
    
    
    
    <category term="工作" scheme="https://daoxuan.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="工作" scheme="https://daoxuan.gitee.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>数字签名</title>
    <link href="https://daoxuan.gitee.io/2021/11/02/5e4c0b9ce5a2.html"/>
    <id>https://daoxuan.gitee.io/2021/11/02/5e4c0b9ce5a2.html</id>
    <published>2021-11-02T13:54:42.000Z</published>
    <updated>2021-11-02T13:55:36.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对文件本身加密可能是个耗时过程，比如这封Email足够大，那么私钥加密整个文件以及拿到文件后的解密无疑是巨大的开销。</p><p>数字签名可以解决这个问题：</p><ol type="1"><li>A先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1</li><li>然后用自己私钥对摘要加密，生成的东西叫“数字签名”</li><li>把数字签名加在Email正文后面，一起发送给B（当然，为了防止邮件被窃听你可以用继续公钥加密，这个不属于数字签名范畴）</li><li>B收到邮件后用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充</li><li>B对邮件正文执行哈希运算得到hash值，取名h2</li><li>B会对比第4步数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改。</li></ol><figure><imgsrc="/images/安全.数字签名.assets/1614321306332-13329fb7-71d6-4c39-bcf7-75183fb29c3e.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p><strong>其实就是利用算法（不一定是非对称算法）对原文hash值加密，然后附着到原文的一段数据。数字签名的作用就是验证数据来源以及数据完整性！解密过程则称为数字签名验证</strong></p><p><strong> </strong></p><p>如果中间人同时篡改了Email正文和数字签名，那B收到邮件无法察觉啊。</p><p>答案：数字签名的生成需要对方私钥，所以数字签名很难被伪造。万一私钥泄漏了呢，不好意思，你私钥都能弄丢了那这篇文章当我白写。（私钥绝对保密不参与传输）</p><p>公钥是公开的并且可以自行导入到电脑，如果有人比如C偷偷在B的电脑用自己公钥替换了A的公钥，然后用自己的私钥给B发送Email，这时B收到邮件其实是被C冒充的但是他无法察觉。</p><p>答案：确实存在这种情况！解决办法就是数字证书</p><p>参考</p><ol type="1"><li>https://www.cnblogs.com/kingsleylam/p/4985571.html</li></ol>]]></content>
    
    
    <summary type="html">数字签名</summary>
    
    
    
    <category term="安全" scheme="https://daoxuan.gitee.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="https://daoxuan.gitee.io/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="数字签名" scheme="https://daoxuan.gitee.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>安全.数字证书</title>
    <link href="https://daoxuan.gitee.io/2021/10/27/602c653329a2.html"/>
    <id>https://daoxuan.gitee.io/2021/10/27/602c653329a2.html</id>
    <published>2021-10-27T08:51:38.000Z</published>
    <updated>2022-05-01T01:58:19.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="目录">目录</h3><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B">申请流程</a></li><li><ahref="#%E8%AF%81%E4%B9%A6%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">证书使用流程</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h3 id="申请流程">申请流程**</h3><ol type="1"><li>自己<strong>本地先生成一对密匙</strong>，然后拿着<strong>自己的公匙</strong>以及其他信息（比如说企业名称啊什么的）去CA申请数字证书。</li><li>CA在拿到这些信息后，会选择一种<strong>单向Hash算法</strong>（比如说常见的MD5）对这些信息进行加密，加密之后的东西我们称之为<strong>摘要</strong>：</li><li>单向Hash算法有一种特点就是单向不可逆的，只要原始内容有一点变化，加密后的数据都将会是千差万别（当然也有很小的可能性会重复，有兴趣的小伙伴鸽巢原理了解一下），这样就防止了信息被篡改。</li><li>生成摘要后还不算完，<strong>CA还会用自己的私匙对摘要进行加密</strong>，摘要加密后的数据我们称之为数字签名。</li><li>最后，CA将会把我们的<strong>申请信息（包含服务器的公匙）和数字签名</strong>整合在一起，由此而生成<strong>数字证书</strong>。</li><li>然后CA将数字证书传递给我们</li></ol><figure><imgsrc="/images/安全.数字证书.assets/1614323760202-763ba837-24b7-4e73-bd45-3e29c5d76438.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="证书使用流程">证书使用流程</h3><p>服务器在获取到数字证书后，服务器会将数字证书发送给客户端，客户端就需要用CA的公匙解密数字证书并验证数字证书的合法性。那我们如何能拿到CA的公匙呢？我们的电脑和浏览器中已经内置了一部分权威机构的根证书，这些根证书中包含了CA的公匙。</p><p>之所以是根证书，是因为现实生活中，认证中心是分层级的，也就是说有顶级认证中心，也有下面的各个子级的认证中心，是一个树状结构，计算机中内置的是最顶级机构的根证书，不过不用担心，根证书的公匙在子级也是适用的。</p><p>客户端用CA的公匙解密数字证书，如果解密成功则说明证书来源于合法的认证机构。解密成功后，客户端就拿到了摘要。</p><p>此时，客户端会按照和CA一样的Hash算法将申请信息生成一份摘要，并和解密出来的那份做对比，如果相同则说明内容完整，没有被篡改。最后，客户端安全的从证书中拿到服务器的公匙就可以和服务器进行安全的非对称加密通信了。服务器想获得客户端的公匙也可以通过相同方式</p><h3 id="参考">参考</h3><ol type="1"><li>https://zhuanlan.zhihu.com/p/61702029</li><li>https://www.jianshu.com/p/4932cb1499bf</li></ol>]]></content>
    
    
    <summary type="html">安全加密信息</summary>
    
    
    
    <category term="安全" scheme="https://daoxuan.gitee.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="https://daoxuan.gitee.io/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="数字证书" scheme="https://daoxuan.gitee.io/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>安全.加密</title>
    <link href="https://daoxuan.gitee.io/2021/10/27/def6c9efa48c.html"/>
    <id>https://daoxuan.gitee.io/2021/10/27/def6c9efa48c.html</id>
    <published>2021-10-27T07:50:20.000Z</published>
    <updated>2021-11-02T13:54:12.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>为了保证消息的保密性，就需要用到加密和解密。加解密算法目前主流的分为<strong>对称加密和非对称加密</strong>。</p></blockquote><h2 id="对称加密">对称加密</h2><blockquote><p>对称加密（共享密匙加密）</p></blockquote><p>客户端和服务器<strong>公用一个密匙</strong>用来对消息加解密，这种方式称为<strong>对称加密</strong>。客户端和服务器<strong>约定</strong>好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息</p><figure><imgsrc="/images/安全.加密/1614220965960-9c303346-48e7-473c-9f61-88d14c5f442f.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="优点">优点</h3><p>对称加密解决了http中消息保密性的问题</p><h3 id="缺点">缺点</h3><p>对称加密虽然保证了消息保密性，但是因为客户端和服务器共享一个密匙，这样就使得密匙特别容易泄露</p><figure><imgsrc="/images/安全.加密/1614221021852-11298c4c-b024-4c60-9b88-aae90134bb45.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="常见方式">常见方式</h3><ol type="1"><li>DES: <strong>Data Encryption Standard</strong> ：替换+移位、56位密钥、64位数据块、速度快、密钥易产生</li><li>3DES：<strong>Triple DES</strong> (三重DES):两个56位的密钥K1、K2加密:K1加密-&gt;K2解密-&gt;K1加密 解密:K1解密-&gt;K2加-&gt;K1解密</li><li>RC5: <strong>Rivest Cipher 5</strong>RSA数据安全公司的很多产品都使用了RC-5。</li><li>IDEA法: <strong>International Data Encryption Algorithm</strong>128位密钥、64位数据块、比DES的加密性好、对计算机功能要求相对低,PGP</li><li>AES算法: <strong>Advanced Encryption Standard</strong>高级加密标准,又称Rijndael加m密法,是美国政府采用的一种区块加密标准。</li></ol><h2 id="非对称加密">非对称加密</h2><blockquote><p>非对称加密（公有密匙加密）</p></blockquote><p>既然对称加密中，密匙那么容易泄露，那么我们可以采用一种非对称加密的方式来解决。</p><p>采用非对称加密时，<strong>客户端和服务端均拥有一个公有密匙和一个私有密匙</strong>。公有密匙可以对外暴露，而私有密匙只有自己可见。</p><p>使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开。这样客户端在发送消息前，<strong>先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密</strong></p><figure><imgsrc="/images/安全.加密/1614221148302-300b91f8-13b8-4b28-b52e-c74fb84ec1fd.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="优点-1">优点</h3><p>1）非对称加密采用公有密匙和私有密匙的方式，解决了http中消息保密性问题，而且使得私有密匙泄露的风险降低；</p><p>2）因为公匙加密的消息只有对应的私匙才能解开，所以较大程度上保证了消息的来源性以及消息的准确性和完整性</p><h3 id="缺点-1">缺点</h3><ol type="1"><li>非对称加密时需要使用到接收方的公匙对消息进行加密，但是公匙不是保密的，任何人都可以拿到，中间人也可以。那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是服务器的。服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息；</li><li>非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，<strong>https将两种加密结合了起来</strong></li></ol><p><strong><imgsrc="/images/安全.加密/1614224826514-cc045717-b1a4-4735-858a-e62670a656d3.png"alt="image.png" /></strong></p><h3 id="常见方式-1">常见方式</h3><ol type="1"><li><p>RSA:2048位(或1024位)密钥、计算量极大、难破解</p><blockquote><p>RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（AdiShamir）和伦纳德·阿德曼（LeonardAdleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的[1]</p></blockquote></li><li><p>Elgamal:安全性依赖于计算有限域上离散对数这一难题</p></li><li><p>ECC: <strong>椭圆曲线加密算法</strong></p></li></ol>]]></content>
    
    
    <summary type="html">安全加密信息</summary>
    
    
    
    <category term="安全" scheme="https://daoxuan.gitee.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="安全" scheme="https://daoxuan.gitee.io/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="加密" scheme="https://daoxuan.gitee.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
