[{"title":"安全.DSA算法","url":"/2023/03/17/4a1b273297f7.html","content":"\n\n\n## 目录\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n## 参考 \n\n- [参考](#%E5%8F%82%E8%80%83)\n- [简介](#%E7%AE%80%E4%BB%8B)\n- [DSA签名及验证](#dsa%E7%AD%BE%E5%90%8D%E5%8F%8A%E9%AA%8C%E8%AF%81)\n- [签名及验证协议：](#%E7%AD%BE%E5%90%8D%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%8D%8F%E8%AE%AE)\n- [DSA使用过程](#dsa%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B)\n- [Java实现DSA生成公私钥并加解密](#java%E5%AE%9E%E7%8E%B0dsa%E7%94%9F%E6%88%90%E5%85%AC%E7%A7%81%E9%92%A5%E5%B9%B6%E5%8A%A0%E8%A7%A3%E5%AF%86)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n## 参考 \n\n1. https://www.cnblogs.com/bonelee/p/12931317.html\n\n## 简介\n\nDSA（Digital Signature Algorithm）是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。\nDSA加密算法主要依赖于整数有限域离散对数难题，素数P必须足够大，且p-1至少包含一个大素数因子以抵抗Pohlig &Hellman算法的攻击。M一般都应采用信息的HASH值。DSA加密算法的安全性主要依赖于p和g，若选取不当则签名容易伪造，应保证g对于p-1的大素数因子不可约。其安全性与RSA相比差不多。\n\nDSA 一般用于数字签名和认证。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多.\n\n\n\n##  DSA签名及验证\n\nDSA算法中应用了下述参数：\n\np：L bits长的素数。L是64的倍数，范围是512到1024；\n\nq：p – 1的160bits的素因子；\n\ng：g = h^((p-1)/q) mod p，h满足h < p – 1, h^((p-1)/q) mod p > 1；\n\nx：x < q，x为私钥 ；\n\ny：y = g^x mod p ，( p, q, g, y )为公钥；\n\nH( x )：One-Way Hash函数。DSS中选用SHA( Secure Hash Algorithm )。\n\np, q, g可由一组用户共享，但在实际应用中，使用公共模数可能会带来一定的威胁。\n\n## 签名及验证协议：\n\n* 1.P产生随机数k，k < q；\n* 2.P计算 r = ( g^k mod p ) mod q\n  s = ( k^(-1) (H(m) xr)) mod q\n  签名结果是( m, r, s )。\n* 3.验证时计算 w = s^(-1)mod q\n  u1 = ( H( m ) w ) mod q\n  u2 = ( r w ) mod q\n  v = (( g^u1 * y^u2 ) mod p ) mod q\n  若v = r，则认为签名有效。\n\n举例：B 发消息给A，使用DSA算法进行签名\n\n1.生成素数p=59、素数q=29、h=11、私钥x=7，临时密钥k=10，消息摘要H(M)=26\n\n2.生成g：\n\ng=h^(p-1)/qmod p → g=11^2 mod 59 → g=3\n\n3.计算公钥y\n\ny=g^xmod p → y=3^7 mod 59 →y=2187 mod 59 →y=4\n\n4.进行签名计算\n\nr = (g^k mod p) mod q → r=(59049 mod 59) mod 29 →r=20\n\ns = [k^-1 (H(M) + xr) ] mod q → s=3·(26+140)mod 29 → s=5\n\n5.A收到消息后进行签名验证\n\nw=(s’)^-1mod q → w=6 mod 29 =6\n\nu1=[H(M’)w] mod q → u1=156 mod 29 = 11\n\nu2=(r’)wmod q → u2=120 mod 29=4\n\nv=[(g^u1 · y^u2) mod p] mod q → v= (45349632 mod 59) mod 29 =20\n\nv=r=20\n\n6.验证成功；\n\n## DSA使用过程\n\n过程：\n\n\n\n```undefined\n　　　　　构建密钥对：\n\n　　　　　　　　发送方：　　1.构建密钥对\n\n　　　　　　　　　　　　　　2.公布密钥\n\n　　　　　发送数据 ：\n\n　　　　　　　　发送方：　　1.使用私钥对数据签名\n\n　　　　　　　　　　　　　　2.发送签名，数据\n\n　　　　　　　　　　　　　  3.使用公钥，签名验证数据\n```\n\n## Java实现DSA生成公私钥并加解密\n\n代码如下\n\n\n\n```csharp\npackage com.tencent.blue.utils;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.security.*;\n\n/**\n * Created by cuiran on 19/1/11.\n * 生成一对文件 publicKey.key 和 privateKey.key ,\n * 公钥要用户发送 ( 文件 , 网络等方法 ) 给其它用户 , 私钥保存在本地\n * 1.生成秘钥对\n * 2.使用私钥进行签名\n * 3.使用公钥校验签名\n * 意义上的加密解密 非内容型的加密解密\n */\npublic class DSA {\n\n    public static void main(String[] args) {\n        //初始化秘钥对写入到文件 生成的是X.509编码格式的 生成的私钥是PKCS#8编码格式\n        getKeyPairs();\n        //明文签名\n        SignatureData(\"我是cayden，银行账户为622XXXX\");\n        //校验签名文件\n        checkSignature();\n\n    }\n\n\n\n    /**\n     * 生成秘钥对写入到文件\n     * @return\n     */\n    public static boolean getKeyPairs() {\n        try {\n            //初始化秘钥管理器\n            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"DSA\");\n            keyPairGenerator.initialize(512);\n            KeyPair keyPair = keyPairGenerator.genKeyPair();\n            //获取秘钥对\n            PublicKey publicKey = keyPair.getPublic();\n            PrivateKey privateKey = keyPair.getPrivate();\n\n            //直接写入公钥\n            ObjectOutputStream out_pub = new ObjectOutputStream(new FileOutputStream(\"publicKey.key\"));\n            out_pub.writeObject(publicKey);\n            out_pub.close();\n            System.out.println(\"生成的公钥内容为_____:\\n \"+publicKey);\n            //直接写入私钥\n            ObjectOutputStream out_pri = new ObjectOutputStream(new FileOutputStream(\"privateKey.key\"));\n            out_pri.writeObject(privateKey);\n            out_pri.close();\n            System.out.println(\"生成的私钥内容为_____:\\n \"+privateKey);\n            System.out.println(\"\\n生成密钥对成功...\");\n            return true;\n        } catch (java.lang.Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 使用私钥进行签名\n     * @return\n     */\n    public static boolean SignatureData(String  info){\n        try {\n            //1.读取生成的私钥对明文进行签名\n            ObjectInputStream in_pri = new ObjectInputStream(new java.io.FileInputStream(\"privateKey.key\"));\n            PrivateKey privateKey = (PrivateKey) in_pri.readObject();\n            in_pri.close();\n            //初始化签名 对明文开始签名\n            Signature signature = Signature.getInstance(\"DSA\");\n            signature.initSign(privateKey);\n            signature.update(info.getBytes());\n            // 对信息的数字签名\n            byte[] signedbytes = signature.sign();\n            System.out.println(\"签名为_____:\"+signedbytes);\n            //把签名的密文存到文件中\n            ObjectOutputStream out_signature =new ObjectOutputStream(new FileOutputStream(\"signature.data\"));\n            //把明文和签名一起写入 也可以分别写入\n            out_signature.writeObject(info);\n            out_signature.writeObject(signedbytes);\n            out_signature.close();\n            System.out.println(\"秘钥签名完成.......\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"私钥签名失败....\");\n        }\n        return false;\n    }\n\n    /**\n     * 用公钥进行校验\n     * @return\n     */\n    public static boolean checkSignature(){\n        try {\n            //读取公钥\n            ObjectInputStream in_pub=new ObjectInputStream(new FileInputStream(\"publicKey.key\"));\n            PublicKey publicKey = (PublicKey) in_pub.readObject();\n            //读取签名文件\n            ObjectInputStream in_signature=new ObjectInputStream(new FileInputStream(\"signature.data\"));\n            //读取签名信息\n            String info = (String) in_signature.readObject();\n            //用公钥进行校验\n            byte[] signedbytes = (byte[]) in_signature.readObject();\n            Signature signature = Signature.getInstance(\"DSA\");\n            signature.initVerify(publicKey);\n            signature.update(info.getBytes());\n            //签名信息校验\n            if (signature.verify(signedbytes)) {\n                System.out.println(\"签名的内容为____:\" + info);\n                System.out.println(\"签名文件校验正常....\");\n                return true;\n            } else{\n                System.out.println(\"签名校验失败\");\n                return false;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n\n    }\n\n\n} 运行结果如下\n```\n\n\n\n\n\n\n\n![img](http://site.daoxuan/file/2023/03/17/21-0411-667368-a64e1cbc6020efa9.png)\n\n运行结果\n","categories":["安全"],"tags":["安全"]},{"title":"安全--HTTP原理","url":"/2021/10/27/0201fdb0936f.html","content":"\n## 目录\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n## 参考\n\n- [参考](#%E5%8F%82%E8%80%83)\n  - [**1.HTTPS概述**](#1https%E6%A6%82%E8%BF%B0)\n  - [**2.加密算法与数字签名**](#2%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D)\n  - [**3.HTTP传输的安全风险**](#3http%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9)\n  - [**4.HTTP到HTTPS演进**](#4http%E5%88%B0https%E6%BC%94%E8%BF%9B)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n## 参考\n\n\n\n### **1.HTTPS概述**\n\nHTTPS，全称HyperText Transfer Protocol over Secure Socket Layer，设计初衷是为了保证数据传输安全。国内大型互联网巨头在2016开始大力推行https，期间关于https的重大事件有：\n\n1. Google搜索引擎让https的网站在搜索排名中更靠前。\n2. 从2017年开始，chrome浏览器把只采用http的网站标记为不安全网站。\n3. 苹果要求App Store中的所有应用都必须使用https加密链接。\n4. 微信小程序也要求必须使用https。\n5. 新一代的http/2协议的支持需要以https为基础。\n\n众所周知，http（超文本传输协议）是客户端浏览器与web服务器之间的通信协议，而https协议可以认为是HTTP + SSL/TLS，在http之下tcp之上加了ssl一层，用于对应用层数据的加解密。如下图所示。\n\n![image](http://site.daoxuan/file/2022/09/10/17-1619-1614330084640-6db0a060-8bdc-4ea8-8d58-dd5a61e73add.jpeg)\n\nSSL，全称Secure Socket Layer，安全套接字层，在1994年为Netscape所研发，SSL为TCP/IP与各应用层协议之间提供数据通信的安全保障。\n\nTLS，全称Transport Layer\nSecurity，传输层安全，前身就是SSL，最初的几个版本是SSL1.0、SSL2.0、SSL3.0，1999年从3.1开始被IETF（[Internet Engineering Task Force](https://link.zhihu.com/?target=https%3A//www.ietf.org/)，互联网工程任务组）标准化并改名，发展至今已经有TLS1.0、TLS1.1.，TLS1.2几个版本，由于SSL3.0和TLS1.0存在安全漏洞，已经很少使用了，目前使用较多的还是TLS1.1、TLS1.2。TLS1.3还在发展中。\n\nOpenSSL是一个强大的安全套接字层密码库，包含了主要的密码算法、常见的密钥和证书封装管理功能以及SSL协议。最新动态可以参考OpenSSL官方：[https://www.openssl.org](https://link.zhihu.com/?target=https%3A//www.openssl.org/)。\n\n### **2.加密算法与数字签名**\n\n密码学社会发展中应用广泛，在公元前400年，古希腊人就发明了置换密码，在第二次世界大战期间，德国启用了“恩尼格玛”密码机。\n\n加密算法一般分为对称加密和非对称加密。对称加密，即加密和解密都用的同一套密钥，分流式、分组两种，常见的对称加密算法有：DES、AES-GCM、ChaCha20-Poly1305等。\n\n非对称加密，即加密使用的密钥和解密使用的密钥是不同的，分公钥和私钥。公钥和算法是公开的，私钥是保密的。相比对称加密，非对称加密算法的性能较差，但安全性更高。由于非对称加密的加密特性，非对称加密算法能加密的数据长度是有限的，常见的非对称加密算法有：RSA、DSA、ECDSA、DH、ECDHE。\n\n讲加密算法，也有必要讲讲哈希算法，哈希算法是将任意长度的信息转换成较短的、固定长度的值。通常其长度要比信息小很多，且算法不可逆，常见的有MD5、SHA-1、SHA-2、SHA-256等。MD5常用语计算文件的哈希值用于判断文件在传输中是否有变化。而数字签名就是信息在信息的后面加上一段信息经过hash后的值，用于证明信息没有被修改后。\n\n### **3.HTTP传输的安全风险**\n\n我们可以通过抓包来了解http的安全风险，使用工具是wireshark。在网上任意找一个使用http协议非安全的网站，发送请求，通过http and ip.addr == 47.93.102.34做包过滤，如下图所示。\n\n![image](http://site.daoxuan/file/2022/09/10/17-1922-1614330084799-5f4eecd5-ffa5-43b4-923e-44346891fa34.jpeg)\n\n右键点击追踪流->http流\n\n![image](http://site.daoxuan/file/2022/09/10/17-2000-1614330084689-89a1cd4c-efd9-4302-b3da-6ecb4a0c2c3e.jpeg)\n\n红色字体是请求，蓝色字体是响应。\n\n如上图所示抓取的包都是明文包，还是挺可怕的，HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2010-1614330084689-7f0e3c3a-3900-405f-8ce9-0045cd255b9a.jpeg)\n\n可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”。\n\n因此，基于HTTP传输可能会面临以下风险：\n\n1. 窃听风险。\n2. 篡改风险。\n3. 冒充风险。\n\n这也说明https做传输层加密的必要性，下图是使用https安全网站抓取到的包列表情况。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2015-1614330084655-e496ba55-e7c0-494b-be75-4a1d9d5311c5.jpeg)\n\n### **4.HTTP到HTTPS演进**\n\n**方案1：对称加密**\n\n为了防止明文传输，有人想到对传输的信息加密，客户端和服务端约定好加密算法和密钥，如下图所示。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2021-1614330084686-1fdf1f2f-f545-4683-a08a-625c0a454977.jpeg)\n\n此种加密方式，通信双方必须拥有相同的密钥，这种方案有如下问题：\n\n1. 不同的客户端和服务端数量庞大，双方都需要维护大量的密钥、维护成本很高，现实可操作性不强。\n2. 客户端和服务端差异较大，安全级别也不同，管理维护困难，且极易导致密钥泄露。\n\n**方案2：非对称加密**\n\n客户端用公钥对请求内容加密，服务器使用私钥对内容解密。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2025-1614330084649-05bbafe1-a1ad-44ca-8c43-d9f1f1da019c.jpeg)\n\n这种方案也不行，由于公钥是公开的，也就说黑客也能获取公钥，所以第4步服务端返回的报文黑客是能够截取并解密获取传输内容的。\n\n**方案3：非对称加密+对称加密**\n\n![image](http://site.daoxuan/file/2022/09/10/17-2030-1614330084632-70bd9b4e-28ab-4ded-87aa-223316249c2d.jpeg)\n\n在第三步，客户端采用公钥加密密文告诉服务端后续采用对称加密、对称加密的算法和对称密钥，服务端受到密文后通过私钥解密，同意后回复第4段私钥加密密文OK，因此，即使第四段报文被黑客截获并解密也无法获取到对话上下文有用信息，因为第3步密文被黑客截获用公钥也是无法解密的。目前看起来这种方案是可行的，但是如果这样做会有个问题：客户端要如何获取公钥？\n\n**方案4：非对称加密 + 对称加密 + 服务器身份认证**\n\n**如何获取公钥**\n\n如果提供一个下载公钥的地址让客户端去下载，但是下载地址可能也是假的啊！或者开始回话前，服务端发给客户端公钥，但是黑客是可以冒充服务端的，发送给客户端假的公钥。这两种方案都不行，看似无解。\n\n解决这个问题的方案是**SSL证书**，由权威机构发布SSL证书，SSL证书服务端需要申购。如下图所示。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2036-1614330084642-f20c1f2a-bf74-4585-b899-e0b6f1e71478.jpeg)\n\n如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：\n\n（1）证书的发布机构CA\n\n（2）证书的有效期\n\n（3）公钥\n\n（4）证书所有者\n\n（5）签名\n\n等等。\n\n方案4基本上就是现在HTTPS的方案。通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕。\n\n**5.HTTPS工作原理**\n\n正如上一节讨论的方案，HTTPS采用**非对称加密 + 对称加密 + 服务器身份认证来实现可靠的加密传输。**辅助数字签名。\n\n客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例：\n\n1. 首先浏览器读取证书中的**证书所有者、有效期**等信息进行一一校验。\n2. 浏览器开始查找操作系统中已内置的**受信任的证书发布机构CA**，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发。\n\n1.\n    1. 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的，失败返回。\n    2. 如果找到，则继续。\n\n1. 浏览器从操作系统中取出颁发者CA 的公钥，然后对服务器发来的证书里面的**签名**进行解密。浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个**计算的hash值与证书中签名做对比**。\n\n1.\n    1. 如果结果不一致，则校验没通过，失败返回。\n    2. 如果对比结果一致，则证明服务器发来的证书合法，没有被冒充，此时浏览器就可以读取证书中的公钥，用于后续加密了。\n\n如下图所示，简单清晰地呈现了TSL的构成和工作原理。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2044-1614330084702-1218403e-1831-49fc-b62e-a0fc33d7fb17.jpeg)\n\n以上就是HTTPS的基本工作原理。\n\n下面我们来更详细的了解SSL握手过程和使用DH算法的握手阶段。\n\n**SSL握手**\n\n开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程可以用下图说明。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2050-1614330084872-6ac45f2c-b72b-4290-bc05-2032592eb8fd.jpeg)\n\n握手阶段分成五步：\n\n1. 爱丽丝给出协议版本号、一个客户端生成的 随机数（Client random），以及客户端支持的加密方法。\n2. 鲍勃确认双方使用的加密方法，并给出数字证书、以及一个 服务器生成的随机数（Server random）。\n3. 爱丽丝确认数字证书有效，然后生成一个新的 随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。\n4. 鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。\n5. 爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成 对话密钥（session key），用来加密接下来的整个对话过程。\n\n上面的五步，画成一张图，就是下面这样：\n\n![image](http://site.daoxuan/file/2022/09/10/17-2057-1614330084688-2ac265d0-44d4-4254-8c0f-e8690a6b2a9b.jpeg)\n\n握手阶段有三点需要注意：\n\n1. 生成对话密钥一共需要三个随机数。\n2. 握手之后的对话使用 对话密钥（session key） 加密（对称加密），服务器的公钥和私钥只用于加密和解密 **对话密钥（session key）**（非对称加密），无其他作用。\n3. 服务器公钥放在服务器的数字证书之中。\n\n**DH算法的握手阶段**\n\n整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于 **第三个随机数（Premaster secret）**能不能被破解。\n\n虽然理论上，只要服务器的公钥足够长（比如2048位），那么 Premaster secret\n可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的 [RSA算法](https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)，改为 [Diffie-Hellman算法（简称DH算法）](https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2%EF%BC%8D%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2)。\n\n采用 DH算法 后，Premaster secret 不需要传递，双方只要交换各自的参数，就可以算出这个随机数。\n\n![image](http://site.daoxuan/file/2022/09/10/17-2104-1614330085015-eb78ee72-7344-457e-ae0c-463c0347e266.jpeg)\n\n上图中，第三步和第四步由传递 Premaster secret 变成了传递 DH算法 所需的参数，然后双方各自算出 Premaster secret。这样就提高了安全性。\n\n**6.HTTPS vs HTTP**\n\n相比HTTP，HTTPS 传输更加安全\n\n1. 所有信息都是加密传播，黑客无法窃听。【无法窃取】\n2. 具有校验机制，一旦被篡改，通信双方会立刻发现。【无法篡改】\n3. 配备身份证书，防止身份被冒充。【无法冒充】\n\n其他差异：\n\n* http默认端口80，https默认断开443。\n\nHTTPS的缺点：\n\n1. HTTPS比HTTP耗费更多服务器资源（https其实就是建构在SSL/TLS之上的 http协议，所以要比较https比http多用多少服务器资源，主要看SSL/TLS本身消耗多少服务器资源。）\n2. 通信过程复杂，流量成本高。\n3. SSL证书需要花钱，功能越强大的证书费用越高。\n4. SSL证书通常需要绑定IP，不能在同一个IP绑定多个域名。\n\n文章最后附带几个有用链接：\n\n1. https://www.openssl.org\n2. https://github.com/openssl/openssl\n\n参考\n\n1. https://zhuanlan.zhihu.com/p/163740102\n2. https://zhuanlan.zhihu.com/p/61702029\n","categories":["安全"],"tags":["安全","加密"]},{"title":"数字签名","url":"/2021/11/02/5e4c0b9ce5a2.html","content":"\n\n\n对文件本身加密可能是个耗时过程，比如这封Email足够大，那么私钥加密整个文件以及拿到文件后的解密无疑是巨大的开销。\n\n数字签名可以解决这个问题：\n\n1. A先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1\n2. 然后用自己私钥对摘要加密，生成的东西叫“数字签名”\n3. 把数字签名加在Email正文后面，一起发送给B（当然，为了防止邮件被窃听你可以用继续公钥加密，这个不属于数字签名范畴）\n4. B收到邮件后用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充\n5. B对邮件正文执行哈希运算得到hash值，取名h2\n6. B 会对比第4步数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改。\n\n![image.png](/images/安全.数字签名.assets/1614321306332-13329fb7-71d6-4c39-bcf7-75183fb29c3e.png)\n\n**其实就是利用算法（不一定是非对称算法）对原文hash值加密，然后附着到原文的一段数据。数字签名的作用就是验证数据来源以及数据完整性！解密过程则称为数字签名验证**\n\n**\n**\n\n如果中间人同时篡改了Email正文和数字签名，那B收到邮件无法察觉啊。\n\n答案：数字签名的生成需要对方私钥，所以数字签名很难被伪造。万一私钥泄漏了呢，不好意思，你私钥都能弄丢了那这篇文章当我白写。（私钥绝对保密不参与传输）\n\n公钥是公开的并且可以自行导入到电脑，如果有人比如C偷偷在B的电脑用自己公钥替换了A的公钥，然后用自己的私钥给B发送Email，这时B收到邮件其实是被C冒充的但是他无法察觉。\n\n答案：确实存在这种情况！解决办法就是数字证书\n\n参考\n\n1. https://www.cnblogs.com/kingsleylam/p/4985571.html\n","categories":["安全"],"tags":["安全","数字签名"]},{"title":"安全.数字证书","url":"/2021/10/27/602c653329a2.html","content":"\n### 目录\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [申请流程**](#%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B)\n- [证书使用流程](#%E8%AF%81%E4%B9%A6%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B)\n- [参考](#%E5%8F%82%E8%80%83)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n\n\n\n\n### 申请流程**\n\n1. 自己**本地先生成一对密匙**，然后拿着**自己的公匙**以及其他信息（比如说企业名称啊什么的）去CA申请数字证书。\n2. CA在拿到这些信息后，会选择一种**单向Hash算法**（比如说常见的MD5）对这些信息进行加密，加密之后的东西我们称之为**摘要**：\n3. 单向Hash算法有一种特点就是单向不可逆的，只要原始内容有一点变化，加密后的数据都将会是千差万别（当然也有很小的可能性会重复，有兴趣的小伙伴鸽巢原理了解一下），这样就防止了信息被篡改。\n4. 生成摘要后还不算完，**CA还会用自己的****私匙****对****摘要****进行加密**，摘要加密后的数据我们称之为数字签名。\n5. 最后，CA将会把我们的**申请信息（包含服务器的公匙）和数字签名**整合在一起，由此而生成**数字证书**。\n6. 然后CA将数字证书传递给我们\n\n![image.png](/images/安全.数字证书.assets/1614323760202-763ba837-24b7-4e73-bd45-3e29c5d76438.png)\n\n### 证书使用流程\n\n服务器在获取到数字证书后，服务器会将数字证书发送给客户端，客户端就需要用CA的公匙解密数字证书并验证数字证书的合法性。那我们如何能拿到CA的公匙呢？我们的电脑和浏览器中已经内置了一部分权威机构的根证书，这些根证书中包含了CA的公匙。\n\n之所以是根证书，是因为现实生活中，认证中心是分层级的，也就是说有顶级认证中心，也有下面的各个子级的认证中心，是一个树状结构，计算机中内置的是最顶级机构的根证书，不过不用担心，根证书的公匙在子级也是适用的。\n\n客户端用CA的公匙解密数字证书，如果解密成功则说明证书来源于合法的认证机构。解密成功后，客户端就拿到了摘要。\n\n此时，客户端会按照和CA一样的Hash算法将申请信息生成一份摘要，并和解密出来的那份做对比，如果相同则说明内容完整，没有被篡改。最后，客户端安全的从证书中拿到服务器的公匙就可以和服务器进行安全的非对称加密通信了。服务器想获得客户端的公匙也可以通过相同方式\n\n### 参考\n\n1. https://zhuanlan.zhihu.com/p/61702029\n2. https://www.jianshu.com/p/4932cb1499bf\n","categories":["安全"],"tags":["安全","数字证书"]},{"title":"安全.加密","url":"/2021/10/27/def6c9efa48c.html","content":"\n\n\n> 为了保证消息的保密性，就需要用到加密和解密。加解密算法目前主流的分为**对称加密和非对称加密**。\n\n## 对称加密\n\n> 对称加密（共享密匙加密）\n\n客户端和服务器**公用一个密匙**用来对消息加解密，这种方式称为**对称加密**。客户端和服务器**约定**好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息\n\n![img](http://site.daoxuan/file/2023/05/12/07-1955-1614220965960-9c303346-48e7-473c-9f61-88d14c5f442f.png)\n\n### 优点\n\n对称加密解决了http中消息保密性的问题\n\n### 缺点\n\n对称加密虽然保证了消息保密性，但是因为客户端和服务器共享一个密匙，这样就使得密匙特别容易泄露\n\n![image.png](http://site.daoxuan/file/2023/05/12/07-2005-1614221021852-11298c4c-b024-4c60-9b88-aae90134bb45.png)\n\n### 常见方式\n\n1. DES: **Data Encryption Standard** ： 替换+移位、56位密钥、64位数据块、速度快、密钥易产生\n2. 3DES：**Triple DES** (三重DES):两个56位的密钥K1、K2\n   加密:K1加密->K2解密->K1加密\n   解密:K1解密->K2加->K1解密\n3. RC5: **Rivest Cipher 5**  RSA数据安全公司的很多产品都使用了RC-5。\n4. IDEA法: **International Data Encryption Algorithm** 128位密钥、64位数据块、比DES的加密性好、对计算机功能要求相对低,PGP\n5. AES算法: **Advanced Encryption Standard**  高级加密标准,又称 Rijndael加m密法,是美国政府采用的一种区块加密标准。\n\n## 非对称加密\n\n> 非对称加密（公有密匙加密）\n\n既然对称加密中，密匙那么容易泄露，那么我们可以采用一种非对称加密的方式来解决。\n\n采用非对称加密时，**客户端和服务端均拥有一个公有密匙和一个私有密匙**。公有密匙可以对外暴露，而私有密匙只有自己可见。\n\n使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开。这样客户端在发送消息前，**先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密**\n\n![image.png](/images/安全.加密/1614221148302-300b91f8-13b8-4b28-b52e-c74fb84ec1fd.png)\n\n### 优点\n\n1）非对称加密采用公有密匙和私有密匙的方式，解决了http中消息保密性问题，而且使得私有密匙泄露的风险降低；\n\n2）因为公匙加密的消息只有对应的私匙才能解开，所以较大程度上保证了消息的来源性以及消息的准确性和完整性\n\n### 缺点\n\n1. 非对称加密时需要使用到接收方的公匙对消息进行加密，但是公匙不是保密的，任何人都可以拿到，中间人也可以。那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是服务器的。服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息；\n2. 非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，**https将两种加密结合了起来**\n\n**![image.png](/images/安全.加密/1614224826514-cc045717-b1a4-4735-858a-e62670a656d3.png)**\n\n### 常见方式\n\n1. RSA:2048位(或1024位)密钥、计算量极大、难破解\n\n   > RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的 [1]\n\n2. Elgamal:安全性依赖于计算有限域上离散对数这一难题\n\n3. ECC:  **椭圆曲线加密算法**  \n\n## 其他算法\n\n> SM”代表“商密”，即用于商用的、不涉及国家秘密的密码技术。\n>\n> **国密证书** 是使用国密算法进行公钥签名和HASH运算，并采用国密密钥封装的证书\n\n1. SM2 为基于椭圆曲线密码的公钥密码算法标准，包含数字签名、密钥交换和公钥加密，用于替换RSA/Diffie-Hellman/ECDSA/ECDH等国际算法\n2. SM3为密码哈希算法，用于替代MD5/SHA-1/SHA-256等国际算法；\n3. SM4为分组密码，用于替代DES/AES等国际算法；\n4. SM9为基于身份的密码算法，可以替代基于数字证书的PKI/CA体系。\n","categories":["安全"],"tags":["安全","加密"]},{"title":"archives","url":"/archives/index.html","content":""},{"title":"categories","url":"/categories/index.html","content":""},{"title":"schedule","url":"/schedule/index.html","content":""},{"title":"about","url":"/about/index.html","content":""},{"url":"/attachment/index.html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n<pre>\nspring:\n  cloud:\n    gateway:\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n        corsConfigurations:\n          '[/**]':\n            allowedOrigins: # 允许哪些网站的跨域请求\n              - \"http://localhost:8090\"\n              - \"http://www.leyou.com\"\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            allowedHeaders: \"*\" # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: 360000 # 这次跨域检测的有效期\n</pre>\n</body>\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n<script>\n  axios.get(\"http://localhost:10010/user/1?authorization=admin\")\n  .then(resp => console.log(resp.data))\n  .catch(err => console.log(err))\n</script>\n</html>"},{"title":"tags","url":"/tags/index.html","content":""}]